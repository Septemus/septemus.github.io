[{"categories":["college"],"content":" 语法和数据类型 ","date":"2023-07-31","objectID":"/js_note/:0:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"数字 在 JavaScript 里面，数字均为双精度浮点类型（double-precision 64-bit binary format IEEE 754），即一个介于 ±2^−1023 和 ±2^+1024 之间的数字，或约为 ±10^−308 到 ±10^+308，数字精度为 53 位。整数数值仅在 ±(2^53 - 1) 的范围内可以表示准确。 JavaScript 最近添加了 BigInt 的支持，能够用于表示极大的数字。使用 BigInt 的时候有一些注意事项，例如，你不能让 BigInt 和 Number 直接进行运算，你也不能用 Math 对象去操作 BigInt 数字。 请注意，十进制可以以 0 开头，后面接其他十进制数字，但是假如下一个接的十进制数字小于 8，那么该数字将会被当做八进制处理。 0888 // 888 以十进制解析 0777 // 以八进制解析，为十进制的 511 ","date":"2023-07-31","objectID":"/js_note/:1:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"变量的作用域 ECMAScript 6 之前的 JavaScript 没有语句块作用域；相反，语句块中声明的变量将成为语句块所在函数（或全局作用域）的局部变量。例如，如下的代码将在控制台输出 5，因为 x 的作用域是声明了 x 的那个函数（或全局范围），而不是 if 语句块。 if (true) { var x = 5; } console.log(x); // 5 如果使用 ECMAScript 6 中的 let 声明，上述行为将发生变化。 if (true) { let y = 5; } console.log(y); // ReferenceError: y 没有被声明 ","date":"2023-07-31","objectID":"/js_note/:2:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"变量提升 JavaScript 变量的另一个不同寻常的地方是，你可以先使用变量稍后再声明变量而不会引发异常。这一概念称为变量提升；JavaScript 变量感觉上是被“提升”或移到了函数或语句的最前面。但是，提升后的变量将返回 undefined 值。因此在使用或引用某个变量之后进行声明和初始化操作，这个被提升的变量仍将返回 undefined 值。 /** * 例子 1 */ console.log(x === undefined); // true var x = 3; /** * 例子 2 */ // will return a value of undefined var myvar = \"my value\"; (function () { console.log(myvar); // undefined var myvar = \"local value\"; })(); 上面的例子，也可写作： /** * 例子 1 */ var x; console.log(x === undefined); // true x = 3; /** * 例子 2 */ var myvar = \"my value\"; (function () { var myvar; console.log(myvar); // undefined myvar = \"local value\"; })(); 由于存在变量提升，一个函数中所有的var语句应尽可能地放在接近函数顶部的地方。这个习惯将大大提升代码的清晰度。 在 ECMAScript 6 中，let 和 const 同样会被提升变量到代码块的顶部但是不会被赋予初始值。在变量声明之前引用这个变量，将抛出引用错误（ReferenceError）。这个变量将从代码块一开始的时候就处在一个“暂时性死区”，直到这个变量被声明为止。 console.log(x); // ReferenceError let x = 3; ","date":"2023-07-31","objectID":"/js_note/:3:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"函数提升 函数提升 对于函数来说，只有函数声明会被提升到顶部，而函数表达式不会被提升。 /* 函数声明 */ foo(); // \"bar\" function foo() { console.log(\"bar\"); } /* 函数表达式 */ baz(); // 类型错误：baz 不是一个函数 var baz = function () { console.log(\"bar2\"); }; ","date":"2023-07-31","objectID":"/js_note/:4:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"类没有提升 Class declaration hoisting Unlike function declarations, class declarations are not hoisted (or, in some interpretations, hoisted but with the temporal dead zone restriction), which means you cannot use a class before it is declared. new MyClass(); // ReferenceError: Cannot access 'MyClass' before initialization class MyClass {} ","date":"2023-07-31","objectID":"/js_note/:5:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"常量 常量的作用域规则与 let 块级作用域变量相同。若省略 const 关键字，则该标识符将被视为变量。 在同一作用域中，不能使用与变量名或函数名相同的名字来命名常量。例如： // 这会造成错误 function f() {} const f = 5; // 这也会造成错误 function f() { const g = 5; var g; //语句 } 然而，对象属性被赋值为常量是不受保护的，所以下面的语句执行时不会产生错误。 const MY_OBJECT = { key: \"value\" }; MY_OBJECT.key = \"otherValue\"; 同样的，数组的被定义为常量也是不受保护的，所以下面的语句执行时也不会产生错误。 const MY_ARRAY = [\"HTML\", \"CSS\"]; MY_ARRAY.push(\"JAVASCRIPT\"); console.log(MY_ARRAY); //logs ['HTML','CSS','JAVASCRIPT']; ","date":"2023-07-31","objectID":"/js_note/:6:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"字符串转换为数字 parseInt() 不会四舍五入 ","date":"2023-07-31","objectID":"/js_note/:7:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"数组字面值中的多余逗号 你不必列举数组字面值中的所有元素。若你在同一行中连写两个逗号（,），数组中就会产生一个没有被指定的元素，其初始值是 undefined。以下示例创建了一个名为 fish 的数组： var fish = [\"Lion\", , \"Angel\"]; 在这个数组中，有两个已被赋值的元素，和一个空元素（fish[0] 是 “Lion”，fish[1] 是 undefined，而 fish[2] 是 “Angel”）。 如果你在元素列表的尾部添加了一个逗号，它将会被忽略。在下面的例子中，数组的长度是 3，并不存在 myList[3] 这个元素。元素列表中其他所有的逗号都表示一个新元素（的开始）。 备注： 尾部的逗号在早期版本的浏览器中会产生错误，因而编程时的最佳实践方式就是移除它们。 var myList = [\"home\", , \"school\"]; 在下面的例子中，数组的长度是 4，元素 myList[0] 和 myList[2] 缺失。 var myList = [, \"home\", , \"school\"]; 再看一个例子。在这里，该数组的长度是 4，元素 myList[1] 和 myList[3] 被漏掉了。（但是）只有最后的那个逗号被忽略。 var myList = [\"home\", , \"school\", ,]; ","date":"2023-07-31","objectID":"/js_note/:8:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"bool 对象 不要混淆作为布尔对象的真和假与布尔类型的原始值 true 和 false。布尔对象是原始布尔数据类型的一个包装器。 例如： var b = new Boolean(false); if (b) //结果视为真 if (b == true) // 结果视为假 ","date":"2023-07-31","objectID":"/js_note/:9:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"字面量 你不能在一条语句的开头就使用对象字面值，这将导致错误或产生超出预料的行为，因为此时左花括号（{）会被认为是一个语句块的起始符号 ","date":"2023-07-31","objectID":"/js_note/:10:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"对象字面量 可以使用数字或字符串字面值作为属性的名字 对象属性名字可以是任意字符串，包括空串。如果对象属性名字不是合法的 javascript 标识符，它必须用\"“包裹。属性的名字不合法，那么便不能用。访问属性值，而是通过类数组标记 (”[]\") 访问和赋值。 var unusualPropertyNames = { \"\": \"An empty string\", \"!\": \"Bang!\" } console.log(unusualPropertyNames.\"\"); // 语法错误：Unexpected string console.log(unusualPropertyNames[\"\"]); // An empty string console.log(unusualPropertyNames.!); // 语法错误：Unexpected token ! console.log(unusualPropertyNames[\"!\"]); // Bang! 流程控制和错误处理 ","date":"2023-07-31","objectID":"/js_note/:10:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"finally块 finally块包含了在 try 和 catch 块完成后、下面接着 try…catch 的语句之前执行的语句。finally块无论是否抛出异常都会执行。如果抛出了一个异常，就算没有异常处理，finally块里的语句也会执行。 你可以用finally块来令你的脚本在异常发生时优雅地退出；举个例子，你可能需要在绑定的脚本中释放资源。接下来的例子用文件处理语句打开了一个文件（服务端的 JavaScript 允许你进入文件）。如果在文件打开时一个异常抛出，finally块会在脚本错误之前关闭文件。 openMyFile(); try { writeMyFile(theData); //This may throw a error } catch (e) { handleError(e); // If we got a error we handle it } finally { closeMyFile(); // always close the resource } 如果finally块返回一个值，该值会是整个try-catch-finally流程的返回值，不管在try和catch块中语句返回了什么： function f() { try { console.log(0); throw \"bogus\"; } catch (e) { console.log(1); return true; // this return statement is suspended // until finally block has completed console.log(2); // not reachable } finally { console.log(3); return false; // overwrites the previous \"return\" console.log(4); // not reachable } // \"return false\" is executed now console.log(5); // not reachable } f(); // console 0, 1, 3; returns false 用finally块覆盖返回值也适用于在catch块内抛出或重新抛出的异常： function f() { try { throw \"bogus\"; } catch (e) { console.log('caught inner \"bogus\"'); throw e; // this throw statement is suspended until // finally block has completed } finally { return false; // overwrites the previous \"throw\" } // \"return false\" is executed now } try { f(); } catch (e) { // this is never reached because the throw inside // the catch is overwritten // by the return in finally console.log('caught outer \"bogus\"'); } // OUTPUT // caught inner \"bogus\" 循环和迭代 ","date":"2023-07-31","objectID":"/js_note/:11:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"for in 和 for of 的区别 https://juejin.cn/post/6916058482231754765 函数 ","date":"2023-07-31","objectID":"/js_note/:12:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"函数表达式 这样的函数表达式的标识符只在函数体内可见 var myfunc=function disp(){console.log(\"hello\")}; console.log(disp) //ReferenceError: disp is not defined ","date":"2023-07-31","objectID":"/js_note/:13:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"形参 原始参数（比如一个具体的数字）被作为值传递给函数；值被传递给函数，如果被调用函数改变了这个参数的值，这样的改变不会影响到全局或调用函数。 如果你传递一个对象（即一个非原始值，例如Array或用户自定义的对象）作为参数，而函数改变了这个对象的属性，这样的改变对函数外部是可见的，如下面的例子所示： function myFunc(theObject) { theObject.make = \"Toyota\"; } var mycar = { make: \"Honda\", model: \"Accord\", year: 1998 }; var x, y; x = mycar.make; // x 获取的值为 \"Honda\" myFunc(mycar); y = mycar.make; // y 获取的值为 \"Toyota\" // (make 属性被函数改变了) ","date":"2023-07-31","objectID":"/js_note/:14:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"嵌套函数和闭包 你可以在一个函数里面嵌套另外一个函数。嵌套（内部）函数对其容器（外部）函数是私有的。它自身也形成了一个闭包。一个闭包是一个可以自己拥有独立的环境与变量的表达式（通常是函数）。 既然嵌套函数是一个闭包，就意味着一个嵌套函数可以”继承“容器函数的参数和变量。换句话说，内部函数包含外部函数的作用域。 可以总结如下： 内部函数只可以在外部函数中访问。 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量。 下面的例子展示了嵌套函数： function addSquares(a, b) { function square(x) { return x * x; } return square(a) + square(b); } a = addSquares(2, 3); // returns 13 b = addSquares(3, 4); // returns 25 c = addSquares(4, 5); // returns 41 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数： function outside(x) { function inside(y) { return x + y; } return inside; } fn_inside = outside(3); // 可以这样想：给一个函数，使它的值加 3 result = fn_inside(5); // returns 8 result1 = outside(3)(5); // returns 8 ","date":"2023-07-31","objectID":"/js_note/:15:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"闭包对词法环境引用的捆绑 JavaScript 中的函数会形成了闭包。 闭包是由函数以及声明该函数的词法环境组合而成的。该环境包含了这个闭包创建时作用域内的任何局部变量。 function makeAdder(x) { return function (y) { return x + y; }; } var add5 = makeAdder(5); var add10 = makeAdder(10); console.log(add5(2)); // 7 console.log(add10(2)); // 12 在这个示例中，我们定义了 makeAdder(x) 函数，它接受一个参数 x ，并返回一个新的函数。返回的函数接受一个参数 y，并返回x+y的值。 从本质上讲，makeAdder 是一个函数工厂 — 他创建了将指定的值和它的参数相加求和的函数。在上面的示例中，我们使用函数工厂创建了两个新函数 — 一个将其参数和 5 求和，另一个和 10 求和。 add5 和 add10 都是闭包。它们共享相同的函数定义，但是保存了不同的词法环境。在 add5 的环境中，x 为 5。而在 add10 中，x 则为 10。 ","date":"2023-07-31","objectID":"/js_note/:15:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"使用arguments对象 函数的实际参数会被保存在一个类似数组的 arguments 对象中。在函数内，你可以按如下方式找出传入的参数： arguments[i]; 其中i是参数的序数编号（译注：数组索引），以 0 开始。所以第一个传来的参数会是arguments[0]。参数的数量由arguments.length表示。 使用 arguments 对象，你可以处理比声明的更多的参数来调用函数。这在你事先不知道会需要将多少参数传递给函数时十分有用。你可以用arguments.length来获得实际传递给函数的参数的数量，然后用arguments对象来取得每个参数。 例如，设想有一个用来连接字符串的函数。唯一事先确定的参数是在连接后的字符串中用来分隔各个连接部分的字符（译注：比如例子里的分号“；”）。该函数定义如下： function myConcat(separator) { var result = \"\"; // 把值初始化成一个字符串，这样就可以用来保存字符串了！！ var i; // iterate through arguments for (i = 1; i \u003c arguments.length; i++) { result += arguments[i] + separator; } return result; } 你可以给这个函数传递任意数量的参数，它会将各个参数连接成一个字符串“列表”： // returns \"red, orange, blue, \" myConcat(\", \", \"red\", \"orange\", \"blue\"); // returns \"elephant; giraffe; lion; cheetah; \" myConcat(\"; \", \"elephant\", \"giraffe\", \"lion\", \"cheetah\"); // returns \"sage. basil. oregano. pepper. parsley. \" myConcat(\". \", \"sage\", \"basil\", \"oregano\", \"pepper\", \"parsley\"); 备注： arguments 变量只是“类数组对象”，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的 Array 对象的操作方法。 ","date":"2023-07-31","objectID":"/js_note/:16:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"剩余参数 剩余参数语法允许将不确定数量的参数表示为数组。在下面的例子中，使用剩余参数收集从第二个到最后参数。然后，我们将这个数组的每一个数与第一个参数相乘。这个例子是使用了一个箭头函数，这将在下一节介绍。 function multiply(multiplier, ...theArgs) { return theArgs.map((x) =\u003e multiplier * x); } var arr = multiply(2, 1, 2, 3); console.log(arr); // [2, 4, 6] 表达式和运算符 ","date":"2023-07-31","objectID":"/js_note/:17:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"相等性 在比较两个操作数时，双等号（==）将执行类型转换，并且会按照 IEEE 754 标准对 NaN、-0 和 +0 进行特殊处理（故 NaN != NaN，且 -0 == +0）； 三等号（===）做的比较与双等号相同（包括对 NaN、-0 和 +0 的特殊处理）但不进行类型转换；如果类型不同，则返回 false； 在相等运算中，应注意以下几个问题： 如果操作数是布尔值，则先转换为数值，其中 false 转为 0，true 转换为 1。 如果一个操作数是字符串，另一个操作数是数字，则先尝试把字符串转换为数字。 如果一个操作数是字符串，另一个操作数是对象，则先尝试把对象转换为字符串。 如果一个操作数是数字，另一个操作数是对象，则先尝试把对象转换为数字。 如果两个操作数都是对象，则比较引用地址。如果引用地址相同，则相等；否则不等。 下面是特殊操作数的相等比较。 console.log(\"1\" == 1); //返回true。字符串被转换为数字 console.log(true == 1); //返回true。true被转换为1 console.log(false == 0); //返回true。false被转换为0 console.log(null == 0); //返回false console.log(undefined == 0); //返回false console.log(undefined == null); //返回true console.log(NaN == \"NaN\"); //返回false console.log(NaN ==1); //返回false console.log(NaN == NaN); //返回false console.log(NaN != NaN); //返回true NaN\rNaN与任何值都不相等，包括它自己。null 和 undefined 值相等，但是它们是不同类型的数据。在相等比较中，null 和 undefined 不允许被转换为其他类型的值。\r下面是特殊操作数的全等比较。 console.log(null === undefined); //返回false console.log(0 === \"0\"); //返回false console.log(0 === false); //返回false 对于对象，主要比较引用的地址，不比较对象的值。 var a = new String(\"abcd); //定义字符串\"abcd\"对象 var b = new String(\"abcd); //定义字符串\"abcd\"对象 console.log(a === b); //返回false console.log(a == b); //返回false 在上面示例中，两个对象的值相等，但是引用地址不同，所以它们既不想等，也不全等。因此，对于复合型对象来说，相等==和全等===运算的结果是相同的。 ","date":"2023-07-31","objectID":"/js_note/:18:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"delete delete操作符，删除一个对象的属性（不能是继承的或者私有的）或者一个数组中某一个键值。语法如下： delete objectName.property; delete objectName[index]; objectName是一个对象名，property 是一个已经存在的属性，index是数组中的一个已经存在的键值的索引值。 你能使用 delete 删除各种各样的隐式声明，但是被var声明的除外。 如果 delete 操作成功，属性或者元素会变成 undefined。如果 delete可行会返回true，如果不成功返回false。 x = 42; var y = 43; myobj = new Number(); myobj.h = 4; // create property h delete x; // returns true (can delete if declared implicitly) delete y; // returns false (cannot delete if declared with var) delete Math.PI; // returns false (cannot delete predefined properties) delete myobj.h; // returns true (can delete user-defined properties) delete myobj; // returns true (can delete if declared implicitly) 删除数组元素 删除数组中的元素时，数组的长度是不变的，例如删除 a[3], a[4]，a[4] 和 a[3] 仍然存在变成了 undefined。 delete 删除数组中的一个元素，这个元素就不在数组中了。例如，trees[3]被删除，trees[3] 仍然可寻址并返回 undefined。 var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\"); delete trees[3]; if (3 in trees) { // 不会被执行 } 如果想让数组中存在一个元素但是是undefined值，使用undefined关键字而不是delete操作。如下： trees[3] 分配一个 undefined,但是这个数组元素仍然存在： var trees = new Array(\"redwood\", \"bay\", \"cedar\", \"oak\", \"maple\"); trees[3] = undefined; if (3 in trees) { // this gets executed（会被执行） } ","date":"2023-07-31","objectID":"/js_note/:19:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"instanceof instanceof 如果所判别的对象确实是所指定的类型，则返回true。其语法如下： objectName instanceof objectType; objectName 是需要做判别的对象的名称，而objectType是假定的对象的类型，例如Date或 Array. 当你需要确认一个对象在运行时的类型时，可使用instanceof. 例如，需要 catch 异常时，你可以针对抛出异常的类型，来做不同的异常处理。 例如，下面的代码使用 instanceof 去判断 theDay 是否是一个 Date 对象。因为 theDay 是一个 Date 对象，所以 if 中的代码会执行。 var theDay = new Date(1995, 12, 17); if (theDay instanceof Date) { // statements to execute } 字符串 ","date":"2023-07-31","objectID":"/js_note/:20:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"String 对象 除非必要，应该尽量使用 String 字面值，因为 String 对象的某些行为可能并不与直觉一致。举例： const firstString = \"2 + 2\"; //创建一个字符串字面量 const secondString = new String(\"2 + 2\"); // 创建一个字符串对象 eval(firstString); // 返回数字 4 eval(secondString); // 返回包含 \"2 + 2\" 的字符串对象 正则表达式 ","date":"2023-07-31","objectID":"/js_note/:21:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"exec和match的区别 使用.exec()方法时，与’g’标志关联的行为是不同的。（“class”和“argument”的作用相反：在.match()的情况下，字符串类（或数据类型）拥有该方法，而正则表达式只是一个参数，而在.exec()的情况下，它是拥有该方法的正则表达式，其中字符串是参数。对比str.match(re)与re.exec(str) ), ‘g’标志与.exec()方法一起使用获得迭代进展。而match遇到g标志会直接输出全局范围内匹配的串,而且不会输出括号里面的缓存。 var xArray; while ((xArray = re.exec(str))) console.log(xArray); // produces: // [\"fee \", index: 0, input: \"fee fi fo fum\"] // [\"fi \", index: 4, input: \"fee fi fo fum\"] // [\"fo \", index: 7, input: \"fee fi fo fum\"] m 标志用于指定多行输入字符串应该被视为多个行。如果使用 m 标志，^和$匹配的开始或结束输入字符串中的每一行，而不是整个字符串的开始或结束。 数组 ","date":"2023-07-31","objectID":"/js_note/:22:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"属性 数组长度可以中途改变,变大变小都可以，但是变小后在变大超出容量的部位都会变成undefined 如果你在代码中给数组下标运算符的是一个非整型,负数数值，那么它将作为一个表示数组的对象的属性创建，而不是数组的元素。（不会被算到length里面） 数组可以在超过当前长度的区域赋值 数组可以被赋值成一个全新的数组 ","date":"2023-07-31","objectID":"/js_note/:23:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"forEach 传递给 forEach 的函数对数组中的每个元素执行一次，数组元素作为参数传递给该函数。未赋值的值不会在 forEach 循环迭代。 注意，在数组定义时省略的元素不会在 forEach 遍历时被列出，但是手动赋值为 undefined 的元素是会被列出的： const sparseArray = [\"first\", \"second\", , \"fourth\"]; sparseArray.forEach((element) =\u003e { console.log(element); }); // first // second // fourth if (sparseArray[2] === undefined) { console.log(\"sparseArray[2] 是 undefined\"); // true } const nonsparseArray = [\"first\", \"second\", undefined, \"fourth\"]; nonsparseArray.forEach((element) =\u003e { console.log(element); }); // first // second // undefined // fourth ","date":"2023-07-31","objectID":"/js_note/:24:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"多维数组 多维数组 数组是可以嵌套的，这就意味着一个数组可以作为一个元素被包含在另外一个数组里面。利用 JavaScript 数组的这个特性，可以创建多维数组。 以下代码创建了一个二维数组。 const a = new Array(4); for (i = 0; i \u003c 4; i++) { a[i] = new Array(4); for (j = 0; j \u003c 4; j++) { a[i][j] = \"[\" + i + \",\" + j + \"]\"; } } 这个例子创建的数组拥有以下行数据： Row 0: [0,0] [0,1] [0,2] [0,3] Row 1: [1,0] [1,1] [1,2] [1,3] Row 2: [2,0] [2,1] [2,2] [2,3] Row 3: [3,0] [3,1] [3,2] [3,3] ","date":"2023-07-31","objectID":"/js_note/:25:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"类数组对象（伪数组） 使用类数组对象 一些 JavaScript 对象，如 document.getElementsByTagName() 返回的 NodeList 或 arguments 等 JavaScript 对象，有与数组相似的行为，但它们并不共享数组的所有方法。arguments 对象提供了 length 属性，但没有实现如 forEach() 等数组方法。 不能直接在类数组对象上调用数组方法。 function printArguments() { arguments.forEach((item) =\u003e { console.log(item); }); // TypeError: arguments.forEach is not a function } 但你可以通过 Function.prototype.call() 间接调用它们。 function printArguments() { Array.prototype.forEach.call(arguments, (item) =\u003e { console.log(item); }); } 数组原型方法也可以用于字符串，因为它们以类似于数组的方式提供对其中字符的顺序访问： Array.prototype.forEach.call(\"a string\", (chr) =\u003e { console.log(chr); }); Map和Set ","date":"2023-07-31","objectID":"/js_note/:26:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"Object 和 Map 比较 Object和Map的比较 一般地，objects会被用于将字符串类型映射到数值。Object允许设置键值对、根据键获取值、删除键、检测某个键是否存在。而Map具有更多的优势。 Object 的键均为 String 类型，在 Map 里键可以是任意类型。 必须手动计算Object的尺寸，但是可以很容易地获取使用Map的尺寸。 Map的遍历遵循元素的插入顺序。 Object有原型，所以映射中有一些缺省的键。（可以用 map = Object.create(null) 回避）。 这三条提示可以帮你决定用Map还是Object： 如果键在运行时才能知道，或者所有的键类型相同，所有的值类型相同，那就使用Map。 如果需要将原始值存储为键，则使用Map，因为Object将每个键视为字符串，不管它是一个数字值、布尔值还是任何其他原始值。 如果需要对个别元素进行操作，使用Object。 ","date":"2023-07-31","objectID":"/js_note/:27:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"Array和Set比较 Array和Set的对比 一般情况下，在 JavaScript 中使用数组来存储一组元素，而新的集合对象有这些优势： 数组中用于判断元素是否存在的indexOf 函数效率低下。 Set对象允许根据值删除元素，而数组中必须使用基于下标的 splice 方法。 数组的indexOf方法无法找到NaN值。 Set对象存储不重复的值，所以不需要手动处理包含重复值的情况。 对象 ","date":"2023-07-31","objectID":"/js_note/:28:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"属性 对象中未赋值的属性的值为undefined（而不是null）。 枚举一个对象的所有属性 从 ECMAScript 5 开始，有三种原生的方法用于列出或枚举对象的属性： for…in 循环 该方法依次访问一个对象及其原型链中所有可枚举的属性。 Object.keys(o) 该方法返回对象 o 自身包含（不包括原型中）的所有可枚举属性的名称的数组。 Object.getOwnPropertyNames(o) 该方法返回对象 o 自身包含（不包括原型中）的所有属性 (无论是否可枚举) 的名称的数组。 ","date":"2023-07-31","objectID":"/js_note/:29:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"构造函数 构造函数中this指向新创建的对象 ","date":"2023-07-31","objectID":"/js_note/:30:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"对象属性索引 在 JavaScript 1.0 中，你可以通过名称或序号访问一个属性。但是在 JavaScript 1.1 及之后版本中，如果你最初使用名称定义了一个属性，则你必须通过名称来访问它；而如果你最初使用序号来定义一个属性，则你必须通过索引来访问它。 这个限制发生在你通过构造函数创建一个对象和它的属性（就象我们之前通过 Car 对象类型所做的那样）并且显式地定义了单独的属性（如 myCar.color = “red”）之时。如果你最初使用索引定义了一个对象属性，例如 myCar[5] = “25”，则你只可能通过 myCar[5] 引用它。 这条规则的例外是从与 HTML 对应的对象，例如 forms 数组。对于这些数组的元素，你总是既可以通过其序号（依据其在文档中出现的顺序），也可以按照其名称（如果有的话）访问它。举例而言，如果文档中的第二个 标签有一个 NAME 属性且值为 “myForm”，访问该 form 的方式可以是 document.forms[1]，document.forms[“myForm”] 或 document.myForm。 ","date":"2023-07-31","objectID":"/js_note/:31:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"get和set 当使用 使用对象初始化器 的方式定义 getter 和 setter 时，只需要在 getter 方法前加 get，在 setter 方法前加 set，当然，getter 方法必须是无参数的，setter 方法只接受一个参数 (设置为新值），例如： var o = { a: 7, get b() { return this.a + 1; }, set c(x) { this.a = x / 2; }, }; 使用 Object.defineProperties 的方法，同样也可以对一个已创建的对象在任何时候为其添加 getter 或 setter 方法。这个方法的第一个参数是你想定义 getter 或 setter 方法的对象，第二个参数是一个对象，这个对象的属性名用作 getter 或 setter 的名字，属性名对应的属性值用作定义 getter 或 setter 方法的函数，下面是一个例子定义了和前面例子一样的 getter 和 setter 方法： var o = { a: 0 }; Object.defineProperties(o, { b: { get: function () { return this.a + 1; }, }, c: { set: function (x) { this.a = x / 2; }, }, }); o.c = 10; // Runs the setter, which assigns 10 / 2 (5) to the 'a' property console.log(o.b); // Runs the getter, which yields a + 1 or 6 这两种定义方式的选择取决于你的编程风格和手头的工作量。当你定义一个原型准备进行初始化时，可以选择第一种方式，这种方式更简洁和自然。但是，当你需要添加 getter 和 setter 方法 —— 因为并没有编写原型或者特定的对象 ——使用第二种方式更好。第二种方式可能更能表现 JavaScript 语法的动态特性——但也会使代码变得难以阅读和理解。 类 ","date":"2023-07-31","objectID":"/js_note/:32:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"初始化 Similar to functions, class declarations also have their expression counterparts. const MyClass = class { // Class body... }; Class expressions can have names as well. The expression’s name is only visible to the class’s body. const MyClass = class MyClassLongerName { // Class body. Here MyClass and MyClassLongerName point to the same class. }; new MyClassLongerName(); // ReferenceError: MyClassLongerName is not defined ","date":"2023-07-31","objectID":"/js_note/:33:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"类不能提升 console.log(Color)//ReferenceError: Cannot access 'Color' before initialization class Color { constructor(...values) { this.values = values; } } ","date":"2023-07-31","objectID":"/js_note/:33:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"方法 Without methods, you may be tempted to define the function within the constructor: class Color { constructor(r, g, b) { this.values = [r, g, b]; this.getRed = function () { return this.values[0]; }; } } console.log(new Color().getRed === new Color().getRed); // false class Color { constructor(...values) { this.values = values; } disp(){ console.log(this.values) } } console.log(new Color().disp===new Color().disp) This also works. However, a problem is that this creates a new function every time a Color instance is created, even when they all do the same thing! In contrast, if you use a method, it will be shared between all instances. A function can be shared between all instances, but still have its behavior differ when different instances call it, because the value of this is different. ","date":"2023-07-31","objectID":"/js_note/:34:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"private In order to refer to a private field anywhere in the class, you must declare it in the class body (you can’t create a private property on the fly 属性，方法，get，set都能是私有\rChrome exception\rCode run in the Chrome console can access private properties outside the class. This is a DevTools-only relaxation of the JavaScript syntax restriction.\r","date":"2023-07-31","objectID":"/js_note/:35:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"同类可以互相读写 A class method can read the private fields of other instances, as long as they belong to the same class. class Color { #values; constructor(r, g, b) { this.#values = [r, g, b]; } redDifference(anotherColor) { // #values doesn't necessarily need to be accessed from this: // you can access private fields of other instances belonging // to the same class. anotherColor.#values=[1,2,3]; return this.#values[0] - anotherColor.#values[0]; } showV() { console.log(this.#values); } } const red = new Color(255, 0, 0); const crimson = new Color(220, 20, 60); red.redDifference(crimson); // 35 // console.log() crimson.showV() ","date":"2023-07-31","objectID":"/js_note/:35:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"私有属性不存在去访问会直接报错 和公有属性不同 ","date":"2023-07-31","objectID":"/js_note/:35:2","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"派生类对象不可访问基类对象 Derived classes don’t have access to the parent class’s private fields — this is another key aspect to JavaScript private fields being “hard private”. Private fields are scoped to the class body itself and do not grant access to any outside code. class ColorWithAlpha extends Color { log() { console.log(this.#values); // SyntaxError: Private field '#values' must be declared in an enclosing class } } ","date":"2023-07-31","objectID":"/js_note/:35:3","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"static they are not accessible from instances. console.log(new Color(0, 0, 0).isValid); // undefined ","date":"2023-07-31","objectID":"/js_note/:36:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"static initialization block There is also a special construct called a static initialization block, which is a block of code that runs when the class is first loaded. class MyClass { static { MyClass.myStaticProperty = \"foo\"; } } console.log(MyClass.myStaticProperty); // 'foo' ","date":"2023-07-31","objectID":"/js_note/:36:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"super You can have code before super(), but you cannot access this before super() — the language prevents you from accessing the uninitialized this. class ColorWithAlpha extends Color { #alpha; constructor(r, g, b, a) { this.#alpha = a; //ReferenceError: Color is not defined super(r, g, b); } get alpha() { return this.#alpha; } set alpha(value) { if (value \u003c 0 || value \u003e 1) { throw new RangeError(\"Alpha value must be between 0 and 1\"); } this.#alpha = value; } } ","date":"2023-07-31","objectID":"/js_note/:36:2","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"Promise ","date":"2023-07-31","objectID":"/js_note/:37:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"Always return when next function has a argument Always return results when next function has a argument, otherwise callbacks won’t catch the result of a previous promise (with arrow functions, () =\u003e x is short for () =\u003e { return x; }). If the previous handler started a promise but did not return it, there’s no way to track its settlement anymore, and the promise is said to be “floating”. doSomething() .then((url) =\u003e { // I forgot to return this fetch(url); }) .then((result) =\u003e { // result is undefined, because nothing is returned from // the previous handler. // There's no way to know the return value of the fetch() // call anymore, or whether it succeeded at all. }); This may be worse if you have race conditions — if the promise from the last handler is not returned, the next then handler will be called early, and any value it reads may be incomplete. const listOfIngredients = []; doSomething() .then((url) =\u003e { // I forgot to return this fetch(url) .then((res) =\u003e res.json()) .then((data) =\u003e { listOfIngredients.push(data); }); }) .then(() =\u003e { console.log(listOfIngredients); // Always [], because the fetch request hasn't completed yet. }); ","date":"2023-07-31","objectID":"/js_note/:37:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"DOM ","date":"2023-07-31","objectID":"/js_note/:38:0","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"捕获和冒泡 都是冒泡，内部元素的事件会先被触发，然后再触发外部元素，即： 元素的点击事件先触发，然后会触发 元素的点击事件。 都是捕获，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： 元素的点击事件先触发 ，然后再触发 元素的点击事件。 既有捕获又有冒泡，就会先触发捕获再触发冒泡。 ","date":"2023-07-31","objectID":"/js_note/:38:1","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"insertBefore 如果给定的子节点是对文档中现有节点的引用，insertBefore() 会将其从当前位置移动到新位置 ","date":"2023-07-31","objectID":"/js_note/:38:2","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["college"],"content":"HTMLCollection和NodeList 都不是数组 他们看起来可能是一个数组，但其实不是。 你可以像数组一样，使用索引来获取元素。 但无法使用数组的方法： valueOf(), pop(), push(), 或 join() 。 变成数组的方法： const fakeArr = document.getElementsByTagName('div'); const realArr = Array.prototype.slice.call(fakeArr); 或 const fakeArr = document.getElementsByTagName('div'); const realArr = Array.apply(null,fakeArr); 或 const fakeArr = document.getElementsByTagName('div'); const realArr = [...fakeArr] 或 const fakeArr = document.getElementsByTagName('div'); const realArr = Array.from(fakearr) 区别 HTMLCollection是一个动态集合，NodeList是一个静态集合。 其中动态集合和静态集合的最大区别在于：动态集合指的就是元素集合会随着DOM树元素的增加而增加，减少而减少；静态集合则不会受DOM树元素变化的影响。 HTMLCollection是一个对象的索引，而NodeList是一个对象的克隆；所以当这个对象数据量非常大的时候，显然克隆这个对象所需要花费的时间是很长的。 ","date":"2023-07-31","objectID":"/js_note/:38:3","tags":null,"title":"Javascript 学习笔记","uri":"/js_note/"},{"categories":["Projects"],"content":"\rWarning\r该项目所有素材来源于网络，仅用于个人学习用途。\r1 项目展示 ","date":"2023-07-26","objectID":"/xiaomi_store/:0:0","tags":null,"title":"基于web前端的高仿小米商城","uri":"/xiaomi_store/"},{"categories":["Projects"],"content":"1.1 PC端 ","date":"2023-07-26","objectID":"/xiaomi_store/:1:0","tags":null,"title":"基于web前端的高仿小米商城","uri":"/xiaomi_store/"},{"categories":["Projects"],"content":"1.2 移动端 ","date":"2023-07-26","objectID":"/xiaomi_store/:2:0","tags":null,"title":"基于web前端的高仿小米商城","uri":"/xiaomi_store/"},{"categories":["Projects"],"content":"1.3 网址 https://septemusblog.space/xiaomi_store_built_with_html-css-javascript/ 2 所用技术 HTML CSS Javascript Swiper.js Bootstrap ","date":"2023-07-26","objectID":"/xiaomi_store/:3:0","tags":null,"title":"基于web前端的高仿小米商城","uri":"/xiaomi_store/"},{"categories":["college"],"content":" 1 实验内容 底层用 Verilog HDL 语言实现简单的处理器模块设计。 调用存储器模块设计 64×8 的存储器模块。 顶层用原理图方式将简单的处理器模块和存储器模块连接形成简单的计算机核心 部件组成的系统。 将指令序列存入存储器，然后分析指令执行流程 2 代码/原理图 Warning\r由于本次使用modelsim-altera仿真，仿真时顶层不能用原理图，必须要转换为Verilog文件。\r","date":"2023-06-16","objectID":"/computer_organization_course_design/:0:0","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"2.1 顶层文件 ","date":"2023-06-16","objectID":"/computer_organization_course_design/:1:0","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"2.1.1 设计用原理图 ","date":"2023-06-16","objectID":"/computer_organization_course_design/:1:1","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"2.1.2 仿真用Verilog代码 // Copyright (C) 1991-2013 Altera Corporation // Your use of Altera Corporation's design tools, logic functions // and other software and tools, and its AMPP partner logic // functions, and any output files from any of the foregoing // (including device programming or simulation files), and any // associated documentation or information are expressly subject // to the terms and conditions of the Altera Program License // Subscription Agreement, Altera MegaCore Function License // Agreement, or other applicable license agreement, including, // without limitation, that your use is for the sole purpose of // programming logic devices manufactured by Altera and sold by // Altera or its authorized distributors. Please refer to the // applicable agreement for further details. // PROGRAM \"Quartus II 64-Bit\" // VERSION \"Version 13.1.0 Build 162 10/23/2013 SJ Full Version\" // CREATED \"Fri Jun 09 00:49:29 2023\" module computer( reset, clk, Write_read, overflow, M_addr, M_data_out, M_q, PC, R0, R1, R2, R3, state ); input wire reset; input wire clk; output wire Write_read; output wire overflow; output wire [11:0] M_addr; output wire [7:0] M_data_out; output wire [7:0] M_q; output wire [7:0] PC; output wire [7:0] R0; output wire [7:0] R1; output wire [7:0] R2; output wire [7:0] R3; output wire [2:0] state; wire [11:0] M_addr_ALTERA_SYNTHESIZED; wire [7:0] M_data_in; wire [7:0] M_data_out_ALTERA_SYNTHESIZED; wire we; cpu b2v_inst2( .clk(clk), .reset(reset), .M_data_in(M_data_in), .Write_read(we), .overflow(overflow), .M_addr(M_addr_ALTERA_SYNTHESIZED), .M_data_out(M_data_out_ALTERA_SYNTHESIZED), .PC(PC), .R0(R0), .R1(R1), .R2(R2), .R3(R3), .state(state)); defparam b2v_inst2.Add = 4'b0011; defparam b2v_inst2.And = 4'b0101; defparam b2v_inst2.Idle = 4'b0000; defparam b2v_inst2.Jmp = 4'b1011; defparam b2v_inst2.Jz = 4'b1100; defparam b2v_inst2.Load = 4'b0001; defparam b2v_inst2.Move = 4'b0010; defparam b2v_inst2.Or = 4'b0110; defparam b2v_inst2.Read = 4'b1101; defparam b2v_inst2.Shl = 4'b1001; defparam b2v_inst2.Shr = 4'b1000; defparam b2v_inst2.st_0 = 3'b000; defparam b2v_inst2.st_1 = 3'b001; defparam b2v_inst2.st_2 = 3'b010; defparam b2v_inst2.st_3 = 3'b011; defparam b2v_inst2.st_4 = 3'b100; defparam b2v_inst2.Stop = 4'b1111; defparam b2v_inst2.Sub = 4'b0100; defparam b2v_inst2.Swap = 4'b1010; defparam b2v_inst2.Write = 4'b1110; defparam b2v_inst2.Xor = 4'b0111; mif2 b2v_inst3( .clock(clk), .wren(we), .address(M_addr_ALTERA_SYNTHESIZED[5:0]), .data(M_data_out_ALTERA_SYNTHESIZED), .q(M_data_in)); assign Write_read = we; assign M_addr = M_addr_ALTERA_SYNTHESIZED; assign M_data_out = M_data_out_ALTERA_SYNTHESIZED; assign M_q = M_data_in; endmodule ","date":"2023-06-16","objectID":"/computer_organization_course_design/:1:2","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"2.2 RAM初始化内容（mif2.mem） addr +0 +1 +2 +3 +4 +5 +6 +7 0 00 15 24 D0 1F 94 31 E0 8 1E 41 A1 61 84 51 28 2D 16 7B D0 1E C0 19 D0 1D B0 24 13 F0 00 00 00 00 00 39 32 00 00 00 00 00 00 00 00 40 00 00 00 00 00 00 00 00 ","date":"2023-06-16","objectID":"/computer_organization_course_design/:2:0","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"2.3 cpu模块 module cpu( clk, reset, M_data_in, Write_read, M_addr, M_data_out, overflow, R0,R1,R2,R3,PC,state ); //wire [15:0]IR; //wire [7:0] A,R0,R1,R2,R3,PC,RX,RY; //choose_rx_ry crr(clk,IR,R0,R1,R2,R3,RX,RY); //status_machine sm(M_data_in,clk,reset,Write_read,M_addr,M_data_out); //assign M_addr=MAR; //assign M_data_out=MDR; parameter Idle =4'b0000; parameter Load =4'b0001; parameter Move =4'b0010; parameter Add =4'b0011; parameter Sub =4'b0100; parameter And =4'b0101; parameter Or =4'b0110; parameter Xor =4'b0111; parameter Shr =4'b1000; parameter Shl =4'b1001; parameter Swap =4'b1010; parameter Jmp =4'b1011; parameter Jz =4'b1100; parameter Read =4'b1101; parameter Write=4'b1110; parameter Stop =4'b1111; parameter st_0 = 3'b000; parameter st_1 = 3'b001; parameter st_2 = 3'b010; parameter st_3 = 3'b011; parameter st_4 = 3'b100; input clk,reset; input [7:0] M_data_in; output reg [7:0] R0=8'h00,R1=8'h00,R2=8'h00,R3=8'h00,PC=8'h00; output reg overflow; reg [7:0]A=8'h00,RX,RY; //reg [7:0] MDR; reg [15:0] IR=8'h00; //reg[11:0] MAR; output reg Write_read; output reg[11:0]M_addr=12'h000; output reg[7:0]M_data_out=8'h00; output reg [2:0] state=st_0; wire [3:0]OP; reg [2:0] step_counter=3'b000; reg flag1=1'b1; assign OP=IR[15:12]; always@(posedge clk or negedge reset) begin if(!reset) begin R0\u003c=0; R1\u003c=0; R2\u003c=0; R3\u003c=0; RX\u003c=0; RY\u003c=0; PC\u003c=0; M_addr\u003c=0; M_data_out\u003c=0; A\u003c=0; state\u003c=st_0; flag1\u003c=1'b1; end else if(clk) begin //按照步长划分状态，而每个状态又有子状态 //步长为0时执行取指令操作 if(step_counter==3'b000) begin IR\u003c={M_data_in,8'h00}; Write_read\u003c=0; PC\u003c=PC+1; flag1\u003c=1'b1; step_counter\u003c=step_counter+1; end //步长为2时执行取操作数和运算 else if(step_counter==3'b001) begin case(state) //根据寄存器选择RX，RY st_0: begin if(flag1) begin case(IR[11:10]) 2'b00:begin RX\u003c=R0; end 2'b01:begin RX\u003c=R1; end 2'b10:begin RX\u003c=R2; end 2'b11:begin RX\u003c=R3; end endcase case(IR[9:8]) 2'b00:begin RY\u003c=R0; end 2'b01:begin RY\u003c=R1; end 2'b10:begin RY\u003c=R2; end 2'b11:begin RY\u003c=R3; end endcase flag1\u003c=0; end else begin A\u003c=RY; M_addr\u003c=PC; state\u003c=st_1; flag1\u003c=1; end end //以下内容参照实验参考书的表3 st_1: begin if(flag1) begin Write_read\u003c=0; case(OP) Load: R0\u003c={4'h0,IR[11:8]}; Move: RX\u003c=A; Shr: RX\u003c={1'b0,RX[7:1]}; Shl: RX\u003c={RX[6:0],1'b0}; Add: RX\u003c=RX+A; Sub: RX\u003c=RX-A; And: RX\u003c=RX\u0026A; Or: RX\u003c=RX|A; Xor: RX\u003c=RX^A; Swap: RY\u003c=RX; endcase flag1\u003c=0; end else begin if(OP==Stop) begin state\u003c=st_1; end else if(OP==Swap||OP==Jmp||OP==Jz||OP==Read||OP==Write) begin state\u003c=st_2; end else begin if(OP==Load) step_counter\u003c=0; else step_counter\u003c=step_counter+1; state\u003c=st_0; end flag1\u003c=1; end end st_2: begin if(flag1) begin Write_read\u003c=0; case(OP) Swap:RX\u003c=A; Jmp: begin IR[7:0]\u003c=M_data_in; end Read: begin IR[7:0]\u003c=M_data_in; end Write: begin IR[7:0]\u003c=M_data_in; end Jz: begin if(R0==0) begin IR[7:0]\u003c=M_data_in; end end endcase flag1\u003c=0; if(OP!=Swap) PC\u003c=PC+1; end else begin M_data_out\u003c=R0; if(OP==Swap) begin state\u003c=st_0; step_counter\u003c=step_counter+1; end else begin if(OP==Jmp||OP==Read||OP==Write) M_addr\u003c=IR[11:0]; else if(OP==Jz \u0026\u0026 R0==0) M_addr\u003c=IR[11:0]; else M_addr\u003c=PC; state\u003c=st_3; end flag1\u003c=1; end end st_3: begin if(flag1) begin if(OP==Jmp) PC\u003c=IR[11:0]; else if(OP==Jz\u0026\u0026R0==0) PC\u003c=IR[11:0]; else if(OP==Read) Write_read\u003c=0; else if(OP==Write) Write_read\u003c=1; flag1\u003c=0; end else begin if(OP==Read||OP==Write) M_addr\u003c=PC; if(OP==Jmp||OP==Jz) begin state\u003c=st_0; step_counter\u003c=step_counter+1; end else state\u003c=st_4; Write_read\u003c=0; flag1\u003c=1; end end st_4: begin if(flag1) begin if(OP==Read) R0\u003c=M_data_in; flag1\u003c=0; end else begin Write_read\u003c=0; state\u003c=st_0; if(OP==Read) step_counter\u003c=3'b000; else step_counter\u003c=step_counter+1; flag1\u003c=1; end end endcase end //将RX,RY的值赋值回通用寄存器 else if(step_counter==3'b010) begin case(IR[11:10]) 2'b00:begin R0\u003c=RX; end 2'b01:begin R1\u003c=RX; end 2'b10:begin R2\u003c=RX; end 2'b11:begin R3\u003c=RX; end endcase case(IR[9:8]) 2'b00:begin R0\u003c=RY; end 2'b01:begin R1\u003c=RY; end 2'b10:begin R2\u003c=RY; end 2'b11:begin R3\u003c=RY; end endcase step_counter\u003c=3'b000; end end end endmodule 3 仿真波形 4 源码已上传github github仓库：  swjtu_computer_organization_cours","date":"2023-06-16","objectID":"/computer_organization_course_design/:3:0","tags":null,"title":"西南交通大学计组实验-课程设计","uri":"/computer_organization_course_design/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已经过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\rSpecial thanks👍🏿\r感谢何同学提供的参考代码和实验要求！\r0 完结撒花🏵️ 🎉恭喜你已完成所有的计组实验，很有幸被你发现我的博客，我在校的时间里会一直维护计组实验的相关内容并进行答疑。也欢迎大家提出更好的改进建议！ ⭐如果你喜欢我的设计的话，可以在github上follow我并对我的仓库点star，这会让它们被更多的校友发现，你的支持是我最大的动力！ 🧠我在学习过程中也会发布其他技术相关的文章，如果你感兴趣欢迎关注！ 👩🏿‍🎓最后祝各位同学学习顺利，前程似锦！ 1 实验内容 利用quartus提供的IP Core和FPGA内部存储器，完成指令存储器与取指部分设计。 2 代码/原理图 ","date":"2023-05-29","objectID":"/computer_organization_exp8/:0:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.1 顶层文件 ","date":"2023-05-29","objectID":"/computer_organization_exp8/:1:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.2 PC寄存器 此处防抖参考了咕咕与瓜的博客：\rhttps://blog.csdn.net/yck1716/article/details/124656502\rmodule pc_function(input clk,input pc_clr,input manual_plus,output reg[7:0]PC ); parameter S1 = 2'b00, //松开稳定时 S2 = 2'b01, //按下毛刺时 S3 = 2'b10, //按下稳定时 S4 = 2'b11; //松开毛刺时 /*===============================================================20ms计数器=============================================================*/ reg en_counter; //计数使能 reg [19:0] cnt; //计数 reg cnt_full; //只有当计数使能为高电平的时候，计数器才会计数 always@(posedge clk or negedge pc_clr) begin if(!pc_clr) cnt \u003c= 0; else if(en_counter) cnt \u003c= cnt + 1'b1; else cnt \u003c= 0; end //计数满信号（数数到1000000计数满时间到。1000000是1M，当基于clk信号频率进行计数时，cnt_full走过(1/50M)s*1M的时间，即20ms） always@(posedge clk or negedge pc_clr) //当clk接50MHz的信号时，相当于clk在1s内进行了50M次计数，相邻上升沿相间(1/50M)s begin if(!pc_clr) cnt_full \u003c= 1'b0; else if(cnt == 20'd10000) cnt_full \u003c= 1'b1; else cnt_full \u003c= 1'b0; end /*==============================================================判断边沿模块=============================================================*/ reg key_tmp0,key_tmp1; always@(posedge clk or negedge pc_clr) begin if(!pc_clr) begin key_tmp0 \u003c= 1'b1; key_tmp1 \u003c= 1'b1; end else begin key_tmp0 \u003c= manual_plus; //manual_plus按键输入 key_tmp1 \u003c= key_tmp0; end end wire pedge,nedge; assign nedge = (!key_tmp0) \u0026 key_tmp1; //下降沿（下一clk时为0，上一clk时为1） assign pedge = key_tmp0 \u0026 (!key_tmp1); //上升沿（下一clk时为1，上一clk时为0） /*=============================================================状态机模块================================================================*/ reg [1:0] state; reg key_flag; //经消抖后可确认的按下动作 reg key_state; //按键状态，高电平为未按下，低电平为按下状态 always@(posedge clk or negedge pc_clr) begin if(!pc_clr) begin state \u003c= S1; en_counter \u003c= 1'b0; //计数器归零 key_state \u003c= 1'b1; //按键未按下 key_flag \u003c= 1'b0; end else begin case(state) S1: //高电平（松开稳定） begin key_flag \u003c= 1'b0; //按键未按下，不计 key_state \u003c= 1'b1; //按键松开状态 en_counter \u003c= 1'b0; //计数器归零 if(nedge) //检测到下降沿，进入下一个状态同时打开计数器 begin state \u003c= S2; en_counter \u003c= 1'b1; //计数器使能 end else state \u003c= state; //保持目前状态 end S2: //下降沿抖动（按下毛刺） if(cnt_full) //计数满，说明达到稳定状态，关闭计数器，进入下一个状态 begin state \u003c= S3; en_counter \u003c= 1'b0; //计数器归零 key_flag \u003c= 1'b1; //按键可确认已按下 key_state \u003c= 1'b0; //按键按下状态 end else if(pedge) //检测到上升沿（毛刺），跳回S1状态同时关闭计数器 begin en_counter \u003c= 1'b0; //计数器归零 state \u003c= S1; end else state \u003c= state; //保持目前状态 S3: //低电平（按下稳定） begin key_flag \u003c= 1'b0; //一个按键周期测到一次就行，现在可清零了（后面代码编写只在意其posedge） if(pedge) //检测到上升沿，进入下一个状态同时打开计数器 begin state \u003c= S4; en_counter \u003c= 1'b1; //计数器使能 end else state \u003c= state; //保持目前状态 end S4: //上升沿抖动（松开毛刺） if(cnt_full) begin state \u003c= S1; key_state \u003c= 1'b1; end else if(nedge) begin en_counter \u003c= 1'b0; //计数器归零 state \u003c= S3; end else state \u003c= state; //保持目前状态 default: state \u003c= S1; endcase end end always@(posedge key_flag,negedge pc_clr) //key_flag：经消抖后可确认的按下动作 begin if(!pc_clr) PC \u003c= 0; else PC\u003c=PC+1; end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:2:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.3 数码管 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:3:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.4 矩阵键盘 module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[7:0] out= 8'hxx, input key_clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(!key_clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:4:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.5 ROM的内容 addr +0 +1 +2 +3 +4 +5 +6 +7 0 7600 8300 7340 0000 0000 0000 0000 0000 8 0000 0000 0000 0000 0000 0000 0000 0000 16 0000 0000 0000 0000 0000 0000 0000 0000 24 0000 0000 0000 0000 0000 0000 0000 0000 32 0000 0000 0000 0000 0000 0000 0000 0000 40 0000 0000 0000 0000 0000 0000 0000 0000 48 0000 0000 0000 0000 0000 0000 0000 0000 56 0000 0000 0000 0000 0000 0000 0000 0000 64 0000 0000 0000 0000 0000 0000 0000 0000 72 0000 0000 0000 0000 0000 0000 0000 0000 80 0000 0000 0000 0000 0000 0000 0000 0000 88 0000 0000 0000 0000 0000 0000 0000 0000 96 0000 0000 0000 0000 0000 0000 0000 0000 104 0000 0000 0000 0000 0000 0000 0000 0000 112 0000 0000 0000 0000 0000 0000 0000 0000 120 0000 0000 0000 0000 0000 0000 0000 0000 128 0000 0000 0000 0000 0000 0000 0000 0000 136 0000 0000 0000 0000 0000 0000 0000 0000 144 0000 0000 0000 0000 0000 0000 0000 0000 152 0000 0000 0000 0000 0000 0000 0000 0000 160 0000 0000 0000 0000 0000 0000 0000 0000 168 0000 0000 0000 0000 0000 0000 0000 0000 176 0000 0000 0000 0000 0000 0000 0000 0000 184 0000 0000 0000 0000 0000 0000 0000 0000 192 0000 0000 0000 0000 0000 0000 0000 0000 200 0000 0000 0000 0000 0000 0000 0000 0000 208 0000 0000 0000 0000 0000 0000 0000 0000 216 0000 0000 0000 0000 0000 0000 0000 0000 224 0000 0000 0000 0000 0000 0000 0000 0000 232 0000 0000 0000 0000 0000 0000 0000 0000 240 0000 0000 0000 0000 0000 0000 0000 0000 248 0000 0000 0000 0000 0000 0000 0000 0000 ","date":"2023-05-29","objectID":"/computer_organization_exp8/:5:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.6 选择ALU的操作数 module choose_opts( input clk, input [7:0]R0, input [7:0]R1, input [7:0]R2, input [7:0]R3, input [3:0]choose_reg, output [15:0] res ); reg [7:0]opt1,opt2; initial begin opt1\u003c=8'b0000_0000; opt2\u003c=8'b0000_0000; end always@(posedge clk) begin case(choose_reg[3:2]) 2'b00:opt1\u003c=R0; 2'b01:opt1\u003c=R1; 2'b10:opt1\u003c=R2; 2'b11:opt1\u003c=R3; endcase case(choose_reg[1:0]) 2'b00:opt2\u003c=R0; 2'b01:opt2\u003c=R1; 2'b10:opt2\u003c=R2; 2'b11:opt2\u003c=R3; endcase end assign res={opt1,opt2}; endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:6:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.7 寄存器组 module exp5( input clk, input [1:0]RA, input wr, input rd, input [1:0]M, input clr, input manual_plus, input [7:0] key_out, input [7:0] res_alu, input [1:0] res_dest, input enact, output [7:0] R0, output [7:0] R1, output [7:0] R2, output [7:0] R3, output [7:0] PC ); wire [7:0] DATA_INPUT; assign DATA_INPUT=key_out; pc_function pf (clk,clr,manual_plus,PC); reg_function rf (clk,wr,rd,RA,DATA_INPUT,R0,R1,R2,R3,res_alu,res_dest,enact); endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:7:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.8 通用寄存器 module reg_function( input clk, input wr, input rd, input [1:0] RA, input [7:0] DATA_INPUT, output reg[7:0]R0, output reg[7:0]R1, output reg[7:0]R2, output reg[7:0]R3, input [7:0] res_alu, input [1:0] res_dest, input enact ); always@(negedge clk) begin if(res_dest==2'b00\u0026\u0026!enact) begin R0\u003c=res_alu; end else if(res_dest==2'b01\u0026\u0026!enact) begin R1\u003c=res_alu; end else if(res_dest==2'b10\u0026\u0026!enact) begin R2\u003c=res_alu; end else if(res_dest==2'b11\u0026\u0026!enact) begin R3\u003c=res_alu; end else begin case(RA) 2'b00: begin if(wr==0\u0026\u0026rd==1) begin R0\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R0\u003c=res_alu; end end 2'b01: begin if(wr==0\u0026\u0026rd==1) begin R1\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R1\u003c=res_alu; end end 2'b10: begin if(wr==0\u0026\u0026rd==1) begin R2\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R2\u003c=res_alu; end end 2'b11: begin if(wr==0\u0026\u0026rd==1) begin R3\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R3\u003c=res_alu; end end endcase end end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:8:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.9 运算器 module exp4( input clk, input [2:0]S, input cin, input [15:0] operators, output exceed, output [15:0] ans, output [7:0] X, output [7:0] Y, output [7:0] alu_res ); midware mw(operators,X,Y,clk); assign alu_res=ans[7:0]; manipulate man(clk,S,X,Y,cin,ans,exceed); endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:9:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.10 运算器的计算功能 module manipulate( input clk, input [2:0]S, input [7:0]X, input [7:0]Y, input cin, output reg[15:0]ans, output reg exceed ); initial begin ans\u003c=8'h00; end always@(posedge clk) begin case(S) 3'b000:ans\u003c=16'b0000_0000_0000_0000; 3'b001:ans\u003c={8'b0000_0000,X\u0026Y}; 3'b010:ans\u003c={8'b0000_0000,X|Y}; 3'b011:ans\u003c={8'b0000_0000,X^Y}; 3'b100: begin ans\u003c=X+Y+(cin?1'b0:1'b1); end 3'b101:ans\u003c={8'b0000_0000,X[6:0],1'b0}; 3'b110:ans\u003c={8'b0000_0000,1'b0,X[7:1]}; 3'b111:ans\u003c={8'b0000_0000,((X\u003e\u003e7)\u00261)?1:0,X[7:1]}; endcase end always@(posedge clk) begin if(S==3'b100) begin if( ans[8]^ans[7] ) exceed\u003c=1; else exceed\u003c=0; end else exceed\u003c=0; end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:10:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.11 运算器的中间件 module midware( input [15:0]key_out, output reg [7:0] X, output reg [7:0] Y, input clk ); always@(posedge clk) begin X\u003c=key_out[15:8]; Y\u003c=key_out[7:0]; end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:11:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.12 取指令并向各模块发送信号 module execute( input clk, input [15:0] order, input manual_plus, output reg[3:0] choose_reg, output reg[2:0] S, output reg[1:0] res_dest ); always@(posedge clk) begin case(order[15:12]) 4'b0111: begin S\u003c=3'b011; choose_reg\u003c=order[11:8]; res_dest\u003c=order[7:6]; end 4'b1000: begin S\u003c=3'b110; choose_reg\u003c={order[11:10],2'b00}; res_dest\u003c=order[9:8]; end default: begin S\u003c=S; choose_reg\u003c=choose_reg; res_dest\u003c=res_dest; end endcase end endmodule ","date":"2023-05-29","objectID":"/computer_organization_exp8/:12:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"2.14 页面切换 module page_switch( input clk, input [2:0]switch_buttons, input [7:0]R0, input [7:0]R1, input [7:0]R2, input [7:0]R3, input [7:0]pc, input [15:0] order, input [31:0]alu_N, output reg[31:0] N, output reg[1:0] status ); //reg status[1:0]=2'b00; initial begin status\u003c=2'b00; end always@(posedge clk) begin //N\u003c={R0,R1,R2,R3}; casex(switch_buttons) 3'bxx0: status\u003c=2'b00; 3'bx01: status\u003c=2'b01; 3'b011: status\u003c=2'b10; default: status\u003c=status; endcase case(status) 2'b00:N\u003c={R0,R1,R2,R3}; 2'b01:N\u003c={order,8'h00,pc}; 2'b10:N\u003c=alu_N; endcase end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp8_cmd_rdexec 6 上机操作视频 ","date":"2023-05-29","objectID":"/computer_organization_exp8/:13:0","tags":null,"title":"西南交通大学计组实验8-指令分析与执行","uri":"/computer_organization_exp8/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已通过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\rSpecial thanks👍🏿\r感谢何同学提供的参考代码和实验要求！\r1 实验内容 利用quartus提供的IP Core和FPGA内部存储器，完成指令存储器与取指部分设计。 2 代码/原理图 ","date":"2023-05-23","objectID":"/computer_organization_exp7/:0:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.1 顶层文件 ","date":"2023-05-23","objectID":"/computer_organization_exp7/:1:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.2 PC寄存器 module pc_function(input clk,input pc_clr,input [7:0]DATA_INPUT,input [1:0]M,output reg[7:0]PC ); wire [31:0] second_counter; count_second cs (clk,second_counter); always@(negedge clk or negedge pc_clr) begin if(!pc_clr) begin PC\u003c=8'h00; end else if(!clk) begin case(M) 2'b00: begin if(!second_counter) PC\u003c=PC+1; end 2'b01: begin if(!second_counter) PC\u003c=PC-1; end 2'b10: begin PC\u003c=PC; end 2'b11: begin PC\u003c=DATA_INPUT; end endcase end end endmodule ","date":"2023-05-23","objectID":"/computer_organization_exp7/:2:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.3 计时器 module count_second(input clk,output reg[31:0] second_counter=32'h0000_0000); always@(negedge clk) begin if(second_counter==32'd100000) //if(second_counter==32'd1) second_counter \u003c= 0; else second_counter\u003c=second_counter+1; end endmodule ","date":"2023-05-23","objectID":"/computer_organization_exp7/:3:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.4 数码管 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-05-23","objectID":"/computer_organization_exp7/:4:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.5 矩阵键盘 module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[7:0] out= 8'hxx, input key_clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(!key_clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-05-23","objectID":"/computer_organization_exp7/:5:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"2.6 ROM的内容 addr +0 +1 +2 +3 +4 +5 +6 +7 0 0002 0017 002C 0041 0056 006B 0080 0095 8 00AA 00BF 00D4 00E9 00FE 0113 0128 013D 16 0152 0167 017C 0191 01A6 01BB 01D0 01E5 24 01FA 020F 0224 0239 024E 0263 0278 028D 32 02A2 02B7 02CC 02E1 02F6 030B 0320 0335 40 034A 035F 0374 0389 039E 03B3 03C8 03DD 48 03F2 0407 041C 0431 0446 045B 0470 0485 56 049A 04AF 04C4 04D9 04EE 0503 0518 052D 64 0542 0557 056C 0581 0596 05AB 05C0 05D5 72 05EA 05FF 0614 0629 063E 0653 0668 067D 80 0692 06A7 06BC 06D1 06E6 06FB 0710 0725 88 073A 074F 0764 0779 078E 07A3 07B8 07CD 96 07E2 07F7 080C 0821 0836 084B 0860 0875 104 088A 089F 08B4 08C9 08DE 08F3 0908 091D 112 0932 0947 095C 0971 0986 099B 09B0 09C5 120 09DA 09EF 0A04 0A19 0A2E 0A43 0A58 0A6D 128 0A82 0A97 0AAC 0AC1 0AD6 0AEB 0B00 0B15 136 0B2A 0B3F 0B54 0B69 0B7E 0B93 0BA8 0BBD 144 0BD2 0BE7 0BFC 0C11 0C26 0C3B 0C50 0C65 152 0C7A 0C8F 0CA4 0CB9 0CCE 0CE3 0CF8 0D0D 160 0D22 0D37 0D4C 0D61 0D76 0D8B 0DA0 0DB5 168 0DCA 0DDF 0DF4 0E09 0E1E 0E33 0E48 0E5D 176 0E72 0E87 0E9C 0EB1 0EC6 0EDB 0EF0 0F05 184 0F1A 0F2F 0F44 0F59 0F6E 0F83 0F98 0FAD 192 0FC2 0FD7 0FEC 1001 1016 102B 1040 1055 200 106A 107F 1094 10A9 10BE 10D3 10E8 10FD 208 1112 1127 113C 1151 1166 117B 1190 11A5 216 11BA 11CF 11E4 11F9 120E 1223 1238 124D 224 1262 1277 128C 12A1 12B6 12CB 12E0 12F5 232 130A 131F 1334 1349 135E 1373 1388 139D 240 13B2 13C7 13DC 13F1 1406 141B 1430 1445 248 145A 146F 1484 1499 14AE 14C3 14D8 14ED 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp7_cmd_reader 6 上机操作视频 Special thanks👍🏿\r感谢何同学拍摄了以下这段操作视频！🤗\r","date":"2023-05-23","objectID":"/computer_organization_exp7/:6:0","tags":null,"title":"西南交通大学计组实验7-指令存储器与取指令部分的设计","uri":"/computer_organization_exp7/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已通过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\rApr22th bugfixed_1\r感谢钦同学和唐同学指出问题，加法部分结果存在问题，我已更正。但至于为什么不能写成ans\u003c=X+Y+~cin原因我不清楚。\r1 实验内容 设计运算器，将算术逻辑单元和寄存器组集成 2 代码/原理图 ","date":"2023-05-14","objectID":"/computer_organization_exp6/:0:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.1 顶层文件 ","date":"2023-05-14","objectID":"/computer_organization_exp6/:1:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.2 ALU模块 module exp4( input clk, input [2:0]S, input cin, input [15:0] operators, output exceed, output [15:0] ans, output [7:0] X, output [7:0] Y, output [7:0] alu_res ); midware mw(operators,X,Y,clk); assign N={X,Y,ans}; assign alu_res=ans[7:0]; manipulate man(clk,S,X,Y,cin,ans,exceed); endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:2:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.3 ALU的运算功能 module manipulate( input clk, input [2:0]S, input [7:0]X, input [7:0]Y, input cin, output reg[15:0]ans, output reg exceed ); initial begin ans\u003c=8'h00; end always@(posedge clk) begin case(S) 3'b000:ans\u003c=16'b0000_0000_0000_0000; 3'b001:ans\u003c={8'b0000_0000,X\u0026Y}; 3'b010:ans\u003c={8'b0000_0000,X|Y}; 3'b011:ans\u003c={8'b0000_0000,X^Y}; 3'b100: begin ans\u003c=X+Y+(cin?0:1); end 3'b101:ans\u003c={8'b0000_0000,X[6:0],1'b0}; 3'b110:ans\u003c={8'b0000_0000,1'b0,X[7:1]}; 3'b111:ans\u003c={8'b0000_0000,((X\u003e\u003e7)\u00261)?1:0,X[7:1]}; endcase end always@(posedge clk) begin if(S==3'b100) begin if( ans[8]^ans[7] ) exceed\u003c=1; else exceed\u003c=0; end else exceed\u003c=0; end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:3:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.4 ALU的中间件 module midware( input [15:0]key_out, output reg [7:0] X, output reg [7:0] Y, input clk ); always@(posedge clk) begin X\u003c=key_out[15:8]; Y\u003c=key_out[7:0]; end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:4:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.5 寄存器组 module exp5( input clk, input [1:0]RA, input wr, input rd, input [1:0]M, input clr, input [7:0] key_out, input [7:0] res_alu, output [7:0] R0, output [7:0] R1, output [7:0] R2, output [7:0] R3, output [7:0] PC ); wire [7:0] DATA_INPUT; assign DATA_INPUT=key_out; wire [31:0]second_counter; wire [7:0] X,Y; count_second cs (clk,second_counter); pc_function pf (clk,clr,second_counter,DATA_INPUT,M,PC,Y,res_alu); reg_function rf (clk,wr,rd,RA,DATA_INPUT,R0,R1,R2,R3,X,res_alu); endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:5:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.6 寄存器组的计时器 module count_second(input clk,output reg[31:0] second_counter=32'h0000_0000); always@(negedge clk) begin if(second_counter==32'd100000) second_counter \u003c= 0; else second_counter\u003c=second_counter+1; end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:6:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.7 寄存器组的通用寄存器 module reg_function( input clk, input wr, input rd, input [1:0] RA, input [7:0] DATA_INPUT, output reg[7:0]R0, output reg[7:0]R1, output reg[7:0]R2, output reg[7:0]R3, output reg[7:0]X, input [7:0] res_alu ); always@(negedge clk) begin case(RA) 2'b00: begin X\u003c=R0; if(wr==0\u0026\u0026rd==1) begin R0\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R0\u003c=res_alu; end end 2'b01: begin X\u003c=R1; if(wr==0\u0026\u0026rd==1) begin R1\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R1\u003c=res_alu; end end 2'b10: begin X\u003c=R2; if(wr==0\u0026\u0026rd==1) begin R2\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R2\u003c=res_alu; end end 2'b11: begin X\u003c=R3; if(wr==0\u0026\u0026rd==1) begin R3\u003c=DATA_INPUT; end else if(wr==1\u0026\u0026rd==1) begin R3\u003c=res_alu; end end endcase end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:7:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.8 PC寄存器 module pc_function(input clk,input clr,input [31:0]second_counter,input [7:0]DATA_INPUT,input [1:0]M,output reg[7:0]PC,output reg[7:0] Y ,input [7:0] res_alu ); always@(negedge clk or negedge clr) begin if(!clr) begin PC\u003c=8'h00; end else if(!clk) begin case(M) 2'b00: begin if(!second_counter) PC\u003c=PC+1; end 2'b01: begin if(!second_counter) PC\u003c=PC-1; end 2'b10: begin PC\u003c=DATA_INPUT; end 2'b11: begin PC\u003c=res_alu; end endcase Y\u003c=PC; end end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:8:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.9 数码管 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:9:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.10 矩阵键盘 module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[7:0] out= 8'hxx, input key_clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(!key_clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:10:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.11 操作数选择器 module choose_opts( input clk, input [7:0]R0, input [7:0]R1, input [7:0]R2, input [7:0]R3, input [7:0]PC, input flag, input [4:0] choose_reg, output [15:0] res ); reg [7:0]opt1,opt2; initial begin opt1\u003c=8'b0000_0000; opt2\u003c=8'b0000_0000; end always@(posedge clk) begin if(!flag) begin case(choose_reg) 5'b11110:opt1\u003c=R0; 5'b11101:opt1\u003c=R1; 5'b11011:opt1\u003c=R2; 5'b10111:opt1\u003c=R3; 5'b01111:opt1\u003c=PC; default: opt1\u003c=opt1; endcase end else begin case(choose_reg) 5'b11110:opt2\u003c=R0; 5'b11101:opt2\u003c=R1; 5'b11011:opt2\u003c=R2; 5'b10111:opt2\u003c=R3; 5'b01111:opt2\u003c=PC; default: opt2\u003c=opt2; endcase end end assign res={opt1,opt2}; endmodule ","date":"2023-05-14","objectID":"/computer_organization_exp6/:11:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"2.12 选择数码管要显示的内容 module page_switch( input clk, input [2:0]switch_buttons, input [7:0]R0, input [7:0]R1, input [7:0]R2, input [7:0]R3, input [7:0]pc, input [31:0]alu_N, output reg[31:0] N, output reg[1:0] status ); //reg status[1:0]=2'b00; initial begin status\u003c=2'b00; end always@(posedge clk) begin //N\u003c={R0,R1,R2,R3}; casex(switch_buttons) 3'bxx0: status\u003c=2'b00; 3'bx01: status\u003c=2'b01; 3'b011: status\u003c=2'b10; default: status\u003c=status; endcase case(status) 2'b00:N\u003c={R0,R1,R2,R3}; 2'b01:N\u003c={24'h000000,pc}; 2'b10:N\u003c=alu_N; endcase end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp6_calculator 6 上机操作视频 Special thanks👍🏿\r感谢何同学拍摄了以下这段操作视频！🤗\rMay31st bugfixed_2\r视频中加法操作需要按下cin绑定的按钮，此处已经修改，松开的时候是不进位，按下后才是进位，避免了视频中需要按住按钮的情况。\r","date":"2023-05-14","objectID":"/computer_organization_exp6/:12:0","tags":null,"title":"西南交通大学计组实验6-运算器设计","uri":"/computer_organization_exp6/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已通过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\r1 实验内容 CPU寄存器组设计 2 代码/原理图 ","date":"2023-05-04","objectID":"/computer_organization_exp5/:0:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.1 顶层文件 module exp5( input clk, input [1:0]RA, input wr, input rd, input [1:0]M, input clr, input [3:0] KEY_R, input key_clr, output [3:0] KEY_C = 4'b0111, output [7:0] R0, output [7:0] R1, output [7:0] R2, output [7:0] R3, output [7:0] PC, output [2:0] sel, output [31:0] N, output [7:0]codeout ); wire [7:0] DATA_INPUT; wire [7:0] key_out; keymodule km(.clk(clk),.KEY_R(KEY_R),.KEY_C(KEY_C),.out(key_out),.clr(key_clr)); segment_displays sd(.clk(clk),.N(N),.seg(codeout),.sel(sel)); assign DATA_INPUT=key_out; wire [31:0]second_counter; wire [7:0] X,Y; assign N={X,16'h0000,Y}; count_second cs(clk,second_counter); pc_function pf(clk,clr,second_counter,DATA_INPUT,M,PC,Y); reg_function rf(clk,wr,rd,RA,DATA_INPUT,R0,R1,R2,R3,X); endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:1:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.2 根据键盘获取输入 module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[7:0] out= 8'hxx, input clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:2:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.3 计时器 module count_second(input clk,output reg[31:0] second_counter=32'h0000_0000); always@(negedge clk) begin if(second_counter==32'd100000) second_counter \u003c= 0; else second_counter\u003c=second_counter+1; end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:3:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.4 8位7段数码管 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:4:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.5 PC功能 module pc_function(input clk,input clr,input [31:0]second_counter,input [7:0]DATA_INPUT,input [1:0]M,output reg[7:0]PC,output reg[7:0] Y); always@(negedge clk or posedge clr) begin if(clr) begin PC\u003c=8'h00; end else if(!clk) begin case(M) 2'b00: begin if(!second_counter) PC\u003c=PC+1; end 2'b01: begin if(!second_counter) PC\u003c=PC-1; end 2'b10: begin PC\u003c=DATA_INPUT; end default: begin if(!second_counter) PC\u003c=PC+1; end endcase Y\u003c=PC; end end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:5:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.6 寄存器功能 module reg_function( input clk, input wr, input rd, input [1:0] RA, input [7:0] DATA_INPUT, output reg[7:0]R0, output reg[7:0]R1, output reg[7:0]R2, output reg[7:0]R3, output reg[7:0]X ); always@(negedge clk) begin case(RA) 2'b00: begin X\u003c=R0; if(wr==0\u0026\u0026rd==1) begin R0\u003c=DATA_INPUT; end end 2'b01: begin X\u003c=R1; if(wr==0\u0026\u0026rd==1) begin R1\u003c=DATA_INPUT; end end 2'b10: begin X\u003c=R2; if(wr==0\u0026\u0026rd==1) begin R2\u003c=DATA_INPUT; end end 2'b11: begin X\u003c=R3; if(wr==0\u0026\u0026rd==1) begin R3\u003c=DATA_INPUT; end end endcase end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:6:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.7 仿真用顶层文件 module exp5( input clk, input [1:0]RA, input wr, input rd, input [1:0]M, input clr, input [3:0] KEY_R, input key_clr, output [3:0] KEY_C = 4'b0111, output [7:0] R0, output [7:0] R1, output [7:0] R2, output [7:0] R3, output [7:0] PC, output [2:0] sel, output [31:0] N, output [7:0]codeout ); wire [7:0] DATA_INPUT; wire [7:0] key_out; keymodule km(.clk(clk),.KEY_R(KEY_R),.KEY_C(KEY_C),.out(key_out),.clr(key_clr)); segment_displays sd(.clk(clk),.N(N),.seg(codeout),.sel(sel)); assign DATA_INPUT=key_out; // wire [31:0]second_counter; wire [7:0] X,Y; assign N={X,16'h0000,Y}; // count_second cs(clk,second_counter); pc_function pf(clk,clr,DATA_INPUT,M,PC,Y); reg_function rf(clk,wr,rd,RA,DATA_INPUT,R0,R1,R2,R3,X); endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:7:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.8 仿真用key_module module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[7:0] out= 8'hxx, input clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase out=out\u003c\u003c4; out[3:0] = num[3:0]; end // begin // if(num == 5'b1_0000) // begin // if(count_num == 32'b0)begin // count_num = 32'd100001;end // count_num = count_num + 1'b1; // end // else if(count_num \u003e 32'd100000) // begin // count_num = 32'b1; // // //移位 // begin // out=out\u003c\u003c4; // out[3:0] = num[3:0]; // end // end // end end end endmodule ","date":"2023-05-04","objectID":"/computer_organization_exp5/:8:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"2.9 仿真用pc_function module pc_function(input clk,input clr,input [7:0]DATA_INPUT,input [1:0]M,output reg[7:0]PC,output reg[7:0] Y); always@(negedge clk or posedge clr) begin if(clr) begin PC\u003c=8'h00; end else if(!clk) begin case(M) 2'b00: begin PC\u003c=PC+1; end 2'b01: begin PC\u003c=PC-1; end 2'b10: begin PC\u003c=DATA_INPUT; end default: begin PC\u003c=PC+1; end endcase Y\u003c=PC; end end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp5_cpureg ","date":"2023-05-04","objectID":"/computer_organization_exp5/:9:0","tags":null,"title":"西南交通大学计组实验5-CPU寄存器组设计","uri":"/computer_organization_exp5/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已通过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\r1 实验内容 8位算术逻辑单元设计 2 代码/原理图 ","date":"2023-04-27","objectID":"/computer_organization_exp4/:0:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.1 顶层文件 module exp4( input clk, input [2:0]S, input cin, input [3:0] KEY_R, output [3:0] KEY_C = 4'b0111, output [15:0] ans, output [31:0] N, output [7:0] codeout, output [2:0] sel, output [7:0] X, output [7:0] Y ); wire clr; wire [15:0] key_out; keymodule km(.clk(clk),.KEY_R(KEY_R),.KEY_C(KEY_C),.out(key_out),.clr(clr)); midware mw(key_out,X,Y,clk); assign N={X,Y,ans}; assign clr=( (S==3'b000)?1:0 ); segment_displays sd(.clk(clk),.N(N),.seg(codeout),.sel(sel),.clr(clr)); manipulate man(clk,S,X,Y,cin,ans); endmodule ","date":"2023-04-27","objectID":"/computer_organization_exp4/:1:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.2 根据键盘获取输入 module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[15:0] out= 16'hxxxx, input clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-04-27","objectID":"/computer_organization_exp4/:2:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.3 将键盘输入转换为操作数的中间键 module midware( input [15:0]key_out, output reg [7:0] X, output reg [7:0] Y, input clk ); always@(posedge clk) begin X\u003c=key_out[15:8]; Y\u003c=key_out[7:0]; end endmodule ","date":"2023-04-27","objectID":"/computer_organization_exp4/:3:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.4 8位7段数码管 module segment_displays(clk,N,seg,sel,clr); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; input clr; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-04-27","objectID":"/computer_organization_exp4/:4:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.5 运算功能 module manipulate( input clk, input [2:0]S, input [7:0]X, input [7:0]Y, input cin, output reg[15:0]ans ); initial begin ans\u003c=8'h00; end always@(posedge clk) begin case(S) 3'b000:ans\u003c=16'b0000_0000_0000_0000; 3'b001:ans\u003c={8'b0000_0000,X\u0026Y}; 3'b010:ans\u003c={8'b0000_0000,X|Y}; 3'b011:ans\u003c={8'b0000_0000,X^Y}; 3'b100:ans\u003c=X+Y+cin; 3'b101:ans\u003c={8'b0000_0000,X[6:0],1'b0}; 3'b110:ans\u003c={8'b0000_0000,1'b0,X[7:1]}; 3'b111:ans\u003c={8'b0000_0000,((X\u003e\u003e7)\u00261)?1:0,X[7:1]}; endcase end endmodule ","date":"2023-04-27","objectID":"/computer_organization_exp4/:5:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"2.6 仿真用key_module module keymodule( input clk, input [3:0] KEY_R, output reg[3:0] KEY_C = 4'b0111, output reg[15:0] out= 16'hxxxx, input clr // output reg[2:0] press_times=3'b000 ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; // reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin // if(S==3'b000) // begin // out\u003c=16'h0000; // end // else if(clr) begin out\u003c=16'h0000; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase out=out\u003c\u003c4; out[3:0] = num[3:0]; end // begin //// if(num == 5'b1_0000) //// begin //// if(count_num == 32'b0)begin //// count_num = 32'd100001;end //// count_num = count_num + 1'b1; //// end //// else if(count_num \u003e 32'd100000) //// begin //// count_num = 32'b1; //// //// //移位 //// begin //// out=out\u003c\u003c4; //// out[3:0] = num[3:0]; //// end //// end // out=out\u003c\u003c4; // out[3:0] = num[3:0]; // end end end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp4_alu ","date":"2023-04-27","objectID":"/computer_organization_exp4/:6:0","tags":null,"title":"西南交通大学计组实验4-算术逻辑单元（ALU）设计","uri":"/computer_organization_exp4/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rApr22th bugfixed_1\r感谢keaidebeibei和陶同学指出问题，仿真需要注释掉防抖模块并移动赋值语句的位置。已在github添加分支for_simulate专用于仿真。\rApr22th bugfixed_2\r做仿真时发现F8*4A计算错误，发现是没有处理溢出，于是将a改成了9位。\rApr22th update\r实现了动态刷新结果，不再需要来回拨动en。\rSuccess\r代码和输出已通过助教验收。\rFrequency\r使用时必须将clk频率设置成100k\r1 实验内容 用verilog设计一个8位原码一位乘法运算器。乘数和被乘数均为8位原码，被乘数存放在B寄存器中；C寄存器的初始值存放乘数，运算结束后存放乘积的低位部分；A寄存器用于存放部分积，其初始值是0，运算结束后存放乘积的高位部分。A寄存器和C寄存器可级联在一起右移，CR为乘法步数计数器，在每个时钟信号上升沿处理一位乘法的累加和右移，根据乘数的最低位是否为1决定是加被乘数还是0，乘积的符号位由被乘数和乘数的符号位异或得到 2 代码/原理图 ","date":"2023-04-18","objectID":"/computer_organization_exp3/:0:0","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"2.1 顶层文件 module exp3_2( input clk, input [3:0] KEY_R, input clr, input flag1, input flag2, input en, output wire flag3, output [3:0] KEY_C = 4'b0111, output reg[15:0]ans, output reg[8:0] a, output reg[7:0] b, output reg[7:0] c, output reg[3:0] cr_reg, output wire[31:0] N, output [7:0] codeout, output [2:0] sel =3'b000 ); wire [7:0] X,Y; wire [15:0] key_out; keymodule km(.clk(clk),.KEY_R(KEY_R),.clr(clr),.KEY_C(KEY_C),.out(key_out) ); midware (key_out,X,Y); assign flag3=flag1^flag2; assign N={X,Y,ans}; segment_displays sd(.clk(clk),.N(N),.seg(codeout),.sel(sel)); initial begin cr_reg\u003c=4'b0000; end always @(posedge clk) begin if(en) begin if(cr_reg==4'b0000) begin a\u003c=0; b\u003c=X[7:0]; c\u003c=Y[7:0]; cr_reg\u003c=4'b0001; end else begin if(cr_reg==4'b1001) begin ans\u003c={a[7:0],c}; cr_reg\u003c=4'b0000; end else begin if(c\u00261) begin a=a+{1'b0,b}; end c={a\u00261,c[7:1]}; a=a\u003e\u003e1; cr_reg\u003c=cr_reg+1; end end end end endmodule ","date":"2023-04-18","objectID":"/computer_organization_exp3/:1:0","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"2.2 根据键盘获取输入 module keymodule( input clk, input [3:0] KEY_R, input clr, output reg[3:0] KEY_C = 4'b0111, output reg[15:0] out= 16'hxxxx ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk,posedge clr) begin if(clr) begin cnt\u003c=2'b0; out\u003c=16'hxxxx; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase end begin if(num == 5'b1_0000) begin if(count_num == 32'b0)begin count_num = 32'd100001;end count_num = count_num + 1'b1; end else if(count_num \u003e 32'd100000) begin count_num = 32'b1; //移位 begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end end end end end endmodule ","date":"2023-04-18","objectID":"/computer_organization_exp3/:2:0","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"2.2.1 仿真用key_module module keymodule( input clk, input [3:0] KEY_R, input clr, output reg[3:0] KEY_C = 4'b0111, output reg[15:0] out= 16'hxxxx ); reg [1:0] cnt = 2'b0; reg[4:0] num=5'd16; reg[31:0] count_num=32'b1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk,posedge clr) begin if(clr) begin cnt\u003c=2'b0; out\u003c=16'hxxxx; end else begin cnt = cnt + 1'b1; case (cnt) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase if(KEY_R==4'b1111) begin num=5'd16; end else begin case ({KEY_C, KEY_R}) 8'b1011_1110: num = 5'd0; 8'b0111_0111: num = 5'd1; 8'b1011_0111: num = 5'd2; 8'b1101_0111: num = 5'd3; 8'b0111_1011: num = 5'd4; 8'b1011_1011: num = 5'd5; 8'b1101_1011: num = 5'd6; 8'b0111_1101: num = 5'd7; 8'b1011_1101: num = 5'd8; 8'b1101_1101: num = 5'd9; 8'b1110_0111: num = 5'd10; 8'b1110_1011: num = 5'd11; 8'b1110_1101: num = 5'd12; 8'b1110_1110: num = 5'd13; 8'b0111_1110: num = 5'd14; 8'b1101_1110: num = 5'd15; endcase begin out=out\u003c\u003c4; out[3:0] = num[3:0]; end //我不知道为什么必须要用begin end把赋值语句框住。我做的时候没有框住就出不来。 end end end endmodule ","date":"2023-04-18","objectID":"/computer_organization_exp3/:2:1","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"2.3 将键盘输入转换为操作数的中间键 module midware( input [15:0]key_out, output wire [7:0] X, output wire [7:0] Y ); assign X=key_out[15:8]; assign Y=key_out[7:0]; endmodule ","date":"2023-04-18","objectID":"/computer_organization_exp3/:3:0","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"2.4 8位7段数码管 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp3_multiply ","date":"2023-04-18","objectID":"/computer_organization_exp3/:4:0","tags":null,"title":"西南交通大学计组实验3-8位原码一位乘法器设计","uri":"/computer_organization_exp3/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课\rSuccess\r代码和输出已通过助教验收\rupdate\rApr20th 更新：实现了滚动显示数字\rFrequency\r使用时必须将clk频率设置成100k\r1 实验内容 矩阵键盘值扫描读取及显示电路的设计 2 代码/原理图 ","date":"2023-04-12","objectID":"/computer_organization_exp2/:0:0","tags":null,"title":"西南交通大学计组实验2-矩阵键盘设计","uri":"/computer_organization_exp2/"},{"categories":["college"],"content":"2.1 顶层文件 module EXP2( clk, KEY_R, KEY_C, out, ins_num, codeout, sel ); input clk; input [3:0] KEY_R; output reg[3:0] KEY_C = 4'b0111; output reg[31:0] out= 32'h0000_0000; output [3:0] ins_num; output [6:0] codeout; output wire[2:0] sel; reg [31:0]timer = 32'b1; reg [1:0] state_machine = 2'b0; reg valid_input=1; //根据按钮的列扫描信号和行输入信号判断按钮是否被按下 always @(posedge clk) begin state_machine = state_machine + 1'b1; case (state_machine) 2'b00: KEY_C \u003c= 4'b1110; 2'b01: KEY_C \u003c= 4'b1101; 2'b10: KEY_C \u003c= 4'b1011; 2'b11: KEY_C \u003c= 4'b0111; endcase valid_input=!(KEY_R == 4'b1111); begin if(!valid_input) begin if(timer == 32'b0) begin timer = 32'd100001; end timer = timer + 1'b1; end else if(timer \u003e 32'd100000) begin timer = 32'b1; //置数没有在冷却阶段 out=out\u003c\u003c4; out[3:0] = ins_num[3:0]; end end end key2num k2n(clk,KEY_R,KEY_C,ins_num); segment_displays sg(clk,out,codeout,sel); endmodule ","date":"2023-04-12","objectID":"/computer_organization_exp2/:1:0","tags":null,"title":"西南交通大学计组实验2-矩阵键盘设计","uri":"/computer_organization_exp2/"},{"categories":["college"],"content":"2.2 根据键盘按键获得输入的值 module key2num(clk,KEY_R,KEY_C,ins_num); input clk; input [3:0] KEY_R,KEY_C; output reg [3:0] ins_num=0; always@(*) case ({KEY_C, KEY_R}) 8'b1011_1110: ins_num = 4'd0; 8'b0111_0111: ins_num = 4'd1; 8'b1011_0111: ins_num = 4'd2; 8'b1101_0111: ins_num = 4'd3; 8'b0111_1011: ins_num = 4'd4; 8'b1011_1011: ins_num = 4'd5; 8'b1101_1011: ins_num = 4'd6; 8'b0111_1101: ins_num = 4'd7; 8'b1011_1101: ins_num = 4'd8; 8'b1101_1101: ins_num = 4'd9; 8'b1110_0111: ins_num = 4'd10; 8'b1110_1011: ins_num = 4'd11; 8'b1110_1101: ins_num = 4'd12; 8'b1110_1110: ins_num = 4'd13; 8'b0111_1110: ins_num = 4'd14; 8'b1101_1110: ins_num = 4'd15; endcase endmodule ","date":"2023-04-12","objectID":"/computer_organization_exp2/:2:0","tags":null,"title":"西南交通大学计组实验2-矩阵键盘设计","uri":"/computer_organization_exp2/"},{"categories":["college"],"content":"2.3 7段数码管译码器 module segment_displays(clk,N,seg,sel); input clk; input [31:0] N; output reg [7:0] seg; output reg [2:0] sel; reg [3:0]num; always@(posedge clk) begin sel\u003c=sel+1; case(sel) 3'b110:num\u003c=N[3:0]; 3'b101:num\u003c=N[7:4]; 3'b100:num\u003c=N[11:8]; 3'b011:num\u003c=N[15:12]; 3'b010:num\u003c=N[19:16]; 3'b001:num\u003c=N[23:20]; 3'b000:num\u003c=N[27:24]; 3'b111:num\u003c=N[31:28]; endcase end always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00000000; //\"dark\" endcase end endmodule ","date":"2023-04-12","objectID":"/computer_organization_exp2/:3:0","tags":null,"title":"西南交通大学计组实验2-矩阵键盘设计","uri":"/computer_organization_exp2/"},{"categories":["college"],"content":"2.4 仿真用testbench `timescale 1ns/1ns module exp2_tb; reg clk; reg [3:0] key_r=4'b0111; wire [3:0] key_c,out,ins_num; wire [7:0] codeout; initial begin clk=1'b0; end always #50 clk=~clk; always@(posedge clk) begin case(key_r) 4'b0111:key_r=4'b1011; 4'b1011:key_r=4'b1101; 4'b1101:key_r=4'b1110; 4'b1110:key_r=4'b0111; endcase end EXP2 U( .clk(clk), .KEY_R(key_r), .KEY_C(key_c), .out(out), .ins_num(ins_num), .codeout(codeout) ); endmodule 3 引脚分配 4 仿真波形 Note\r由于设计的防抖模块会造成out和codeout信号延迟输出，此处仅关注ins_num的值\r5 源码已上传github github仓库：  swjtu_computer_organization_exp2_matrixkeyboard ","date":"2023-04-12","objectID":"/computer_organization_exp2/:4:0","tags":null,"title":"西南交通大学计组实验2-矩阵键盘设计","uri":"/computer_organization_exp2/"},{"categories":["college"],"content":"\rNote\r此笔记针对西南交通大学2023-2024学年上半学期开设的计组实验课。\rSuccess\r代码和输出已通过助教验收。\r1 实验内容 设计四位加法器 2 代码/原理图 ","date":"2023-04-11","objectID":"/computer_organization_exp1/:0:0","tags":null,"title":"西南交通大学计组实验1-四位全加器设计","uri":"/computer_organization_exp1/"},{"categories":["college"],"content":"2.1 顶层文件 ","date":"2023-04-11","objectID":"/computer_organization_exp1/:1:0","tags":null,"title":"西南交通大学计组实验1-四位全加器设计","uri":"/computer_organization_exp1/"},{"categories":["college"],"content":"2.2 全加器 module full_adder(a,b,c0,s,c1); input a,b,c0; output wire s,c1; wire tmp1,tmp2,tmp3; half_adder ha1(a,b,tmp1,tmp2); half_adder ha2(tmp1,c0,s,tmp3); assign c1=tmp2|tmp3; endmodule ","date":"2023-04-11","objectID":"/computer_organization_exp1/:2:0","tags":null,"title":"西南交通大学计组实验1-四位全加器设计","uri":"/computer_organization_exp1/"},{"categories":["college"],"content":"2.3 半加器 module half_adder(a,b,s,c); input a,b; output wire s,c; assign s=a^b; assign c=a\u0026b; endmodule ","date":"2023-04-11","objectID":"/computer_organization_exp1/:3:0","tags":null,"title":"西南交通大学计组实验1-四位全加器设计","uri":"/computer_organization_exp1/"},{"categories":["college"],"content":"2.4 7段数码管译码器 module segment_displays(num,seg); input [3:0] num; output reg [7:0] seg; always@(num) begin case(num) 4'b0000:seg\u003c=8'b00111111; //\"0\" 4'b0001:seg\u003c=8'b00000110; //\"1\" 4'b0010:seg\u003c=8'b01011011; //\"2\" 4'b0011:seg\u003c=8'b01001111; //\"3” 4'b0100:seg\u003c=8'b01100110; //\"4\" 4'b0101:seg\u003c=8'b01101101; //\"5\" 4'b0110:seg\u003c=8'b01111101; //\"6\" 4'b0111:seg\u003c=8'b00000111; //\"8\" 4'b1000:seg\u003c=8'b01111111; //\"8\" 4'b1001:seg\u003c=8'b01101111; //\"9\" 4'b1010:seg\u003c=8'b01110111; //\"A\" 4'b1011:seg\u003c=8'b01111100; //\"b\" 4'b1100:seg\u003c=8'b00111001; //\"c\" 4'b1101:seg\u003c=8'b01011110; //\"d\" 4'b1110:seg\u003c=8'b01111001; //\"E\" 4'b1111:seg\u003c=8'b01110001; //\"F\" default:seg\u003c=8'b00111111; //\"0\" endcase end endmodule 3 引脚分配 4 仿真波形 5 源码已上传github github仓库：  swjtu_computer_organization_exp_1_4digit_adder ","date":"2023-04-11","objectID":"/computer_organization_exp1/:4:0","tags":null,"title":"西南交通大学计组实验1-四位全加器设计","uri":"/computer_organization_exp1/"},{"categories":["college"],"content":"\rWarning\r此笔记由我个人整理，因此相比教材可能有出入，如果您发现有错误，欢迎和我联系！\rNote\r此笔记针对西南交通大学2022-2023学年上半学期开设的数电理论课。\r1 数字逻辑概论 ","date":"2023-01-14","objectID":"/math_electronic/:0:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.1 数字信号和数字电路 ","date":"2023-01-14","objectID":"/math_electronic/:1:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.1.1 模拟信号和数字信号 1.1.1.1 模拟信号 模拟信号是时间和数值均连续变化的电信号，如正弦波、三角波等 1.1.1.2 数字信号 数字信号是在时间上和数值上均是离散的信号。 1.1.1.3 模拟信号转换为数字信号 处理过程包括：采样、量化、编码。 ","date":"2023-01-14","objectID":"/math_electronic/:1:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.1.2 数字信号的描述方法 周期 (T) —- 表示两个相邻脉冲之间的时间间隔 脉冲宽度 ($t_{w}$)—- 脉冲幅值的50%的两个时间所跨越的时间 占空比 Q —– 表示脉冲宽度占整个周期的百分比 上升时间$t_{r}$ 和下降时间$t_{f}$ —-从脉冲幅值的10%到90% 上升 ","date":"2023-01-14","objectID":"/math_electronic/:1:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.2 数制 ","date":"2023-01-14","objectID":"/math_electronic/:2:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.2.1 二进制数和十进制数转换 1.2.1.1 辗转相除法 将十进制数连续不断地除以2 , 直至商为零，所得余数由低位到高位排列，即为所求二进制数。 1.2.1.2 从高到低比较大小 1.2.1.3 小数的转换 对于二进制的小数部分可写成 $$N_{D} = b_{-1} \\times 2^{-1} + b_{-2} \\times 2^{-2} + \\cdots + b_{-(n-1)} \\times 2^{-(n-1)} + b_{-n} \\times 2^{-n} \\tag{1} $$ 将上式两边分别乘以2，得 $$2 \\times N_{D} = b_{-1} \\times 2^{0} + b_{-2} \\times 2^{-1} + \\cdots + b_{-(n-1)} \\times 2^{-(n-2)} + b_{-n} \\times 2^{-(n-1)} \\tag{2} $$ 由此可见，将十进制小数乘以2，所得乘积的整数即为 $b_1$,不难推知，将十进制小数每次减掉上次所得积中的整数再乘以2，直到满足误差要求进行“四舍五入\"为止，就可完成由十进制小数转换成二进制小数。 Info\r对于八进制和十六进制小数，转换时，由小数点开始，整数部分自右向左，小数部分自左向右，三/四位一组，不够三/四位的添零补齐，则每三/四位二进制数表示一位八/十六进制数\r","date":"2023-01-14","objectID":"/math_electronic/:2:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.3 算数运算 ","date":"2023-01-14","objectID":"/math_electronic/:3:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.3.1 原码、反码、补码 1.3.1.1 原码 原码表示办法：正数符号位是0，负数符号位是1，数值用其绝对值的二进制数表示。例如 $$ +5 = \\boxed{0}101 \\tag{1}$$ $$ -5 = \\boxed{1}101 \\tag{2}$$ 1.3.1.2 反码 反码又称为“1的补码”，正数的反码与正码相同。求二进制负数的反码的简单办法是，符号位不变，将原码的数值逐位求反得到。 1.3.1.3 补码 补码即为反码的最低位加1所得的数 ","date":"2023-01-14","objectID":"/math_electronic/:3:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.4 二进制代码 编码:以一定的规则编制代码来区分和表示不同的数值、字母、符号等信息的过程。 二进制代码的位数(n),与需要编码的事件（或信息）的个数(N)之间应满足以下关系： $$2^{n-1}≤N≤2^{n}$$ ","date":"2023-01-14","objectID":"/math_electronic/:4:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.4.1 BCD码 从4 位二进制数16种代码中,选择10种来表示0~9个数码的方案有很多种。每种方案产生一种BCD码。 BCD码十进制数码 8421码 2421 码 5421 码 余3码 余3循环码 格雷码 0 0000 0000 0000 0011 0010 0000 1 0001 0001 0001 0100 0110 0001 2 0010 0010 0010 0101 0111 0011 3 0011 0011 0011 0110 0101 0010 4 0100 0100 0100 0111 0100 0110 5 0101 1011 1000 1000 1100 0111 6 0110 1100 1001 1001 1101 0101 7 0111 1101 1010 1010 1111 0100 8 1000 1110 1011 1011 1110 1100 9 1001 1111 1100 1100 1010 1101 10 \\ \\ \\ \\ \\ 1111 11 \\ \\ \\ \\ \\ 1110 12 \\ \\ \\ \\ \\ 1010 13 \\ \\ \\ \\ \\ 1011 14 \\ \\ \\ \\ \\ 1001 15 \\ \\ \\ \\ \\ 1000 1.4.1.1 各编码特点 有权码：编码的每一位有固定的权值 无权码：编码没有固定的权值 余3码的特点:当两个十进制的和是10时，相应的二进制和正 好是16，于是可自动产生进位信号,而不需修正.1和9, 2和8,…..6和 4的余3码。便于求10的补码。（本质上一个数的余3码就是这个数加上3的8421码） 格雷码：任何两个相邻代码之间仅有一位不同。 余3码循环码：相邻的两个代码之间仅一位的状态不同。按余3 码循环码组成计数器时，每次转换过程只有一个触发器翻转，译 码时不会发生竞争－冒险现象。（本质上一个数的余3循环码就是这个数加上3的格雷码） 1.4.1.2 用BCD码表示十进制数 对于一个多位的十进制数，需要有与十进制位数相同的几组BCD代码来表示。例如： 1.4.1.3 二进制码与格雷码的转换 二进制码$\\rightarrow$格雷码 格雷码的最高位（最左边）与二进制码的最高位相同。 从左到右，逐一将二进制码相邻的两位相加（舍去进位），作为格雷码的下一位。 格雷码$\\rightarrow$二进制码 二进制码的最高位（最左边）与格雷码的最高位相同。 将产生的每一位二进制码，与下一位相邻的格雷码相加（舍去进位），作为二进制码的下一位。 ","date":"2023-01-14","objectID":"/math_electronic/:4:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.5 二值逻辑变量与基本逻辑运算 逻辑运算的描述方式:逻辑代数表达式、真值表、逻辑图、卡诺图、波形图和硬件描述语言（HDL) 等。 ","date":"2023-01-14","objectID":"/math_electronic/:5:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.5.1 各逻辑门 ","date":"2023-01-14","objectID":"/math_electronic/:5:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.6 逻辑函数 描述输入变量和输出变量之间的因果关系称为逻辑函数 ","date":"2023-01-14","objectID":"/math_electronic/:6:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.6.1 表示办法 1.6.1.1 真值表 1.6.1.2 表达式 逻辑表达式是用与、或、非等运算组合起来，表示逻辑函数与逻辑变量之间关系的逻辑代数式。 只写使输出变量为1的项 每项之中，变量之间是与的关系 变量为1的用原变量，变量为0的用反变量 项与项之间是或的关系 1.6.1.3 逻辑图 用与、或、非等逻辑符号表示逻辑函数中各变量之间的逻辑关系所得到的图形称为逻辑图 思路：将逻辑函数式中所有的与、或、非运算符号用相应的逻辑符号代替，并按照逻辑运算的先后次序将这些逻辑符号连接起来，就得到图电路所对应的逻辑图 1.6.1.4 波形图 用输入端在不同逻辑信号作用下所对应的输出信号的波形图，表示电路的逻辑关系 ","date":"2023-01-14","objectID":"/math_electronic/:6:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"1.6.2 转换 1.6.2.1 真值表$\\rightarrow$逻辑图 根据真值表写出逻辑表达式 化简逻辑表达式 根据表达式画出逻辑图 1.6.2.1 逻辑图$\\rightarrow$真值表 根据逻辑图逐级写出表达式 化简变换求最简与或式 将输入变量的所有取值逐一代入表达式得真值表 2 逻辑代数与硬件描述语言 ","date":"2023-01-14","objectID":"/math_electronic/:6:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.1 逻辑代数的基本定理和恒等式 ","date":"2023-01-14","objectID":"/math_electronic/:7:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.1.1 逻辑代数的基本定律和恒等式 ","date":"2023-01-14","objectID":"/math_electronic/:7:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.1.2 逻辑代数的基本规则 Info\r对偶和反演的区别在于对偶不会把原变量换成反变量\r2.1.2.1 对偶规则 对于任何逻辑函数式，若将其中的与（•）换成或（+），或（+）换成与（•）；并将1换成0，0换成1；那么，所得的新的函数式就是L的对偶式，记作$L’$。 当某个逻辑恒等式成立时，则该恒等式两侧的对偶式也相等。这就是对偶规则。利用对偶规则，可从已知公式中得到更多的运算公式. 2.1.2.2 反演规则 对于任意一个逻辑表达式L，若将其中所有的与（•）换成或（+），或（+）换成与（•）；原变量换为反变量，反变量换为原变量；将1换成0，0换成1；则得到的结果就是原函数的反函数。 ","date":"2023-01-14","objectID":"/math_electronic/:7:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.2 逻辑函数表达式的形式 ","date":"2023-01-14","objectID":"/math_electronic/:8:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.2.1 基本形式 2.2.1.1 与-或表达式 若干与项进行或逻辑运算构成的表达式。由与运算符和或运算符连接起来。如： $$ L = A \\cdot C + \\bar{C} \\cdot D $$ 2.2.1.2 或-与表达式 若干或项进行与逻辑运算构成的表达式。由或运算符和与运算符连接起来。如： $$ L = ( A + C ) \\cdot ( B + \\bar{C} ) \\cdot D $$ 2.2.1.3 其他表达式 ","date":"2023-01-14","objectID":"/math_electronic/:8:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.2.2 最小项与最小项表达式 2.2.2.1 最小项的定义 n个变量$X_{1}, X_{2}, …, X_{n}$的最小项是n个因子的乘积，乘积中包含了全部n个变量，每个变量都以它的原变量或非变量的形式在乘积项中出现，且仅出现一次。一般n个变量的最小项应有$2^{n}$个 2.2.2.2 最小项的性质 对于任意一个最小项，只有一组变量取值使得它的值为1 任意两个最小项的乘积为0 全体最小项之和为1 使最小项为1的一组二进制数所对应的十进制数即为最小项的编号值。 若干个最小项的和等于其余最小项和的反。 两个最小式表达式的与的结果是他们的公共项的并。 2.2.2.3 最小项的表示 通常用$m_i$表示最小项，m 表示最小项,下标i为最小项编号。 ","date":"2023-01-14","objectID":"/math_electronic/:8:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.2.3 最大项与最大项表达式 2.2.3.1 最大项的定义 n个变量$X_1, X_2, …, X_n$的最大项是n个因子或项，每个变量都以它的原变量或非变量的形式在或项中出现，且仅出现一次。一般n个变量的最大项应有$2^n$个 2.2.3.2 最大项的性质 对于任意一个最大项，只有一组变量取值使得它的值为0 任意两个最大项的之和为1 全体最大项之积为0 2.2.3.3 最大项的表示 通常用$M_i$表示最大项，M 表示最大项,下标i为最大项号。 ","date":"2023-01-14","objectID":"/math_electronic/:8:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.2.4 最小项和最大项的关系 两者之间为互补关系：$m_i = \\overline{M_i} ，或者M_i = \\overline{m_i}$ ","date":"2023-01-14","objectID":"/math_electronic/:8:4","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.3 逻辑函数的代数化简法 ","date":"2023-01-14","objectID":"/math_electronic/:9:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.3.1 逻辑函数的最简形式 逻辑函数有不同形式，将其中包含的与项数最少，且每个与项中变量数最少的与-或表达式称为最简与-或表达式 ","date":"2023-01-14","objectID":"/math_electronic/:9:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.3.2 代数化简法 运用逻辑代数的基本定律和恒等式进行化简的方法 2.3.2.1 并项 $$ A + \\bar{A} = 1 $$ $$ L = \\bar{A} \\bar{B} C + \\bar{A} \\bar{B} \\bar{C} = \\bar{A} \\bar{B} ( C + \\bar{C} ) = \\bar{A} \\bar{B} $$ 2.3.2.2 吸收 $$ A + AB = A $$ $$ L = \\bar{A} B + \\bar{A} BCD ( E + F ) = AB $$ 2.3.2.3 消去 $$ A + \\bar{A} B = A + B $$ $$ L = AB + \\bar{A}C + \\bar{B}C = AB + ( \\bar{A} + \\bar{B} ) C = AB + \\overline{AB} C = AB + C $$ 2.3.3 形式变化 通常在一片集成电路芯片中只有一种门电路，为了减少门电路的种类，需要对逻辑函数表达式进行变换。一般通过两次取反可变化。 ","date":"2023-01-14","objectID":"/math_electronic/:9:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.4 逻辑函数的卡诺图化简法 ","date":"2023-01-14","objectID":"/math_electronic/:10:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.4.1 用卡诺图表示逻辑函数 2.4.1.1 引出原理 逻辑函数可以表达为若干最小项相“或”的形式； 逻辑相邻的最小项：如果两个最小项只有一个变量互为反变量，那么，就称这两个最小项在逻辑上相邻; 2.4.1.2 形式 卡诺图：将n变量的全部最小项都填在小方格阵中，并使具有逻辑相邻的最小项在几何位置上也相邻地排列起来，这样,所得到的图形叫n变量的卡诺图。 各小方格对应于各变量不同的组合，而且上下左右在几何上相邻的方格内只有一个因子有差别，这个重要特点成为卡诺图化简逻辑函数的主要依据。 2.4.1.3 画法 当逻辑函数为最小项表达式时，在卡诺图中找出和表达式中最小项对应的小方格填上1，其余的小方格填上0（有时也可用空格表示），就可以得到相应的卡诺图。任何逻辑函数都等于其卡诺图中为1的方格所对应的最小项之和。 ","date":"2023-01-14","objectID":"/math_electronic/:10:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.4.2 化简 2.4.2.1 步骤 将逻辑函数写成最小项表达式 按最小项表达式填卡诺图，凡式中包含了的最小项，其对应方格填1，其余方格填0，如果是无关项填d或x。 合并最小项，即将相邻的1方格圈成一组(包围圈)，每一组含$2^n$个方格，对应每个包围圈写成一个新的乘积项。 将所有包围圈对应的乘积项相加。 2.4.2.2 原则 包围圈内的方格数一定是$2^n$个，且包围圈必须呈矩形。 循环相邻特性包括上下底相邻，左右边相邻和四角相邻。 同一方格可以被不同的包围圈重复包围多次，但新增的包围圈中一定要有原有包围圈未曾包围的方格。 一个包围圈的方格数要尽可能多,包围圈的数目要可能少 当卡诺图中1的个数明显多于0的个数时，可以采取圈0的方式化简，得到原逻辑函数L的反函数，然后再求反，得到L。 ","date":"2023-01-14","objectID":"/math_electronic/:10:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.4.3 无关项 在真值表内对应于变量的某些取值下， 函数的值可以是任意的，或者这些变量的取值根本不会出现，这些变量取值所对应的最小项称为无关项。 Info\r在含有无关项逻辑函数的卡诺图化简中，它的值可以取0或取1，具体取什么值，可以根据使函数尽量得到简化而定。\r","date":"2023-01-14","objectID":"/math_electronic/:10:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.5 硬件描述语言Verilog HDL基础 ","date":"2023-01-14","objectID":"/math_electronic/:11:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.5.1 基本语法规则 2.5.1.1 间隔符 Verilog 的间隔符主要起分隔文本的作用，可以使文本错落有致，便于阅读与修改。间隔符包括空格符（\\b）、TAB 键（\\t）、换行符（\\n）及换页符。 2.5.1.2 注释符 注释只是为了改善程序的可读性,在编译时不起作用。多行注释符(用于写多行注释): /* — */；单行注释符 :以//开始到行尾结束为注释文字 2.5.1.3 标识符 给对象（如模块名、电路的输入与输出端口、变量等）取名所用的字符串。以英文字母或下划线开始如，clk、counter8、_net、bus_A 。 2.5.1.4 关键字 是Verilog语言本身规定的特殊字符串，用来定义语言的结构。例如，module、endmodule、input、output、wire、reg、and等都是关键词。关键词都是小写，关键词不能作为标识符使用 。 2.5.1.5 逻辑值集合 为了表示数字逻辑电路的逻辑状态，Verilog语言规定了4种基本的逻辑值。 val 含义 0 逻辑0、逻辑假 1 逻辑1、逻辑真 x/X 不确定 z/Z 高阻态 2.5.1.6 常量 Verilog允许用参数定义语句定义一个标识符来代表一个常量，称为符号常量。定义的格式为：parameter 参数名1＝常量表达式1，参数名2＝常量表达式2，……；如 parameter BIT=1, BYTE=8, PI=3.14; 2.5.1.7 变量的数据类型 线网类型:是指输出始终根据输入的变化而更新其值的变量,它一般指的是硬件电路中的各种物理连接,常用的网络类型由关键词wire定义wire型变量的定义格式如下：wire [n-1:0] 变量名1，变量名2，…，变量名n； 例: wire L; //将上述电路的输出信号L声明为网络型变量 wire [7:0] data bus; //声明一个8-bit宽的网络型总线变量 Info\rwire型变量未赋值的话缺省值为高阻态Z。\r寄存器类型:寄存器型变量对应的是具有状态保持作用的电等路元件,如触发器寄存器。寄存器型变量只能在initial或always内部被赋值 寄存器类型(不对应具体硬件) 功能说明 reg 常用的寄存器型变量 integer 32位带符号的整数型变量 real 64位带符号的实数型变量 time 64位无符号的时间变量 例: reg clock;//定义一个1位寄存器变量 reg [3:0] counter; //定义一个4位寄存器变量 ","date":"2023-01-14","objectID":"/math_electronic/:11:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.5.3 运算符及优先级 ","date":"2023-01-14","objectID":"/math_electronic/:11:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.5.4 门级元件 元件符号 功能说明 元件符号 功能说明 and 多输入端的与门 nand 多输入端的与非门 or 多输入端的或门 nor 多输入端的或非门 xor 多输入端的异或门 xnor 多输入端的异或非门 buf 多输出端的缓冲器 not 多输出端的反相器 bufif1 控制信号高电平有效的三态缓冲器 notif1 控制信号高电平有效的三态反相器 bufif0 控制信号低电平有效的三态缓冲器 notif0 控制信号低电平有效的三态反相器 ","date":"2023-01-14","objectID":"/math_electronic/:11:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"2.5.5 程序的基本结构 模块是Verilog描述电路的基本单元。对数字电路建模时，用一个或多个模块。不同模块之间通过端口进行连接。 每个模块以关键词module开始，以endmodule结束。 每个模块先要进行端口的定义，并说明输入（input)和输出（output),然后对模块功能进行描述。 除了endmodule语句外，每个语句后必须有分号。 可以用/* — */和//…..对程序的任何部分做注释。 逻辑功能的描述方式有三种不同风格：结构描述方式（门级描述方式,元件列表）、数据流描述方式(assign)，行为描述方式(always) 2.5.5.1 电路模块定义的一般结构 module 模块名（端口名1, 端口名2, 端口名3,…）； 端口类型说明(input, output, inout)； 参数定义(可选)； 数据类型定义(wire, reg等)； 实例化低层模块和基本门级元件； 连续赋值语句（assign）； 过程块结构（initial和always） 行为描述语句； endmodule 2.5.5.2 描述风格 4 组合逻辑电路 ","date":"2023-01-14","objectID":"/math_electronic/:11:4","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.1 组合逻辑电路的分析 ","date":"2023-01-14","objectID":"/math_electronic/:12:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.1.1 定义 其输出状态在任何时刻只取决于同一时刻的输入状态，而与电路原来的状态无关的逻辑电路。 ","date":"2023-01-14","objectID":"/math_electronic/:12:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.1.2 结构特征 输出、输入之间没有反馈延迟通路， 不含记忆单元 ","date":"2023-01-14","objectID":"/math_electronic/:12:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.1.3 分析步骤 由逻辑图写出各输出端的逻辑表达式； 化简和变换逻辑表达式； 列出真值表； 根据真值表或逻辑表达式，经分析最后确定其功能。 ","date":"2023-01-14","objectID":"/math_electronic/:12:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.2 组合逻辑电路的设计 ","date":"2023-01-14","objectID":"/math_electronic/:13:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.2.1 步骤 逻辑抽象：根据实际逻辑问题的因果关系确定输入、输出变量，并定义逻辑状态的含义； 根据逻辑描述列出真值表； 由真值表写出逻辑表达式; 简化和变换逻辑表达式，画出逻辑图。 ","date":"2023-01-14","objectID":"/math_electronic/:13:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.3 组合逻辑电路中的竞争和冒险 ","date":"2023-01-14","objectID":"/math_electronic/:14:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.3.1 原因 ","date":"2023-01-14","objectID":"/math_electronic/:14:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.3.2 检查方法 4.3.2.1 代数法 对具备竞争条件的某变量，将除该变量外其他变量取0或1，若原函数可化成 A+$\\bar{A}$或A$\\cdot \\bar{A}$的形式,则A存在冒险。 4.3.2.2 卡诺图 画出卡诺图，若存在两个相切的卡诺圈，且这个相切的部分没有被另外的卡诺圈包围，则必定存在冒险。 ","date":"2023-01-14","objectID":"/math_electronic/:14:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.3.3 消除办法 4.3.3.1 发现并消除互补变量 4.3.3.2 增加乘积项 4.3.3.3 输出端并联电容器 如果逻辑电路在较慢速度下工作，为了消去竞争冒险，可以在输出端并联一电容器，致使输出波形上升沿和下降沿变化比较缓慢，可对于很窄的负跳变脉冲起到平波的作用。 4.3.3.4 引入选通/封锁脉冲 加封锁脉冲/选通脉冲。在输入信号产生竞争冒险的时间内，1在输出端引入一个逻辑封锁/选通门和控制信号，对脉冲将1可能产生的尖峰干扰脉冲进行屏蔽。1控制信号可由one shot电路产生。 4.3.3.5 接入滤波电路 ","date":"2023-01-14","objectID":"/math_electronic/:14:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4 若干典型的组合逻辑电路 ","date":"2023-01-14","objectID":"/math_electronic/:15:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.1 编码器 能将每一个编码输入信号变换为不同的二进制的代码输出。 Warning\r普通编码器不能有两个或以上有效输入。\r4.4.1.1 分类 普通编码器：任何时候只允许输入一个有效信号，否则输出就会发生混乱。 优先编码器：允许同时输入两个以上的有效编码信号。当同时输入几个有效编码信号时，优先编码器能按预先设定的优先级别，只对其中优先权最高的一个进行编码。 4.4.1.2 典型 4线─2线普通二进制编码器 键盘电路图 键盘真值表 cd4532优先编码器示意图 cd4532优先编码器真值表 用二片CD4532构成16线-4线优先编码器 74HC147真值表 ","date":"2023-01-14","objectID":"/math_electronic/:15:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.2 译码器/数据分配器 译码：译码是编码的逆过程，它能将二进制码翻译成代表某一特定含义的信号.(高低电平信号) 译码器：具有译码功能的逻辑电路称为译码器。 4.4.2.1 2线-4线译码器（74HC139） 4.4.2.2 3线-8线译码器（74HC138) 4.4.2.3 应用 Info\r$D_i$是$A_i$和$B_i+C_{i-1}$的差关于2的模。 $C_i$是借位标志。\r4.4.2.4 七段显示译码器(74HC4511) ","date":"2023-01-14","objectID":"/math_electronic/:15:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.3 数据选择器 数据选择器：能实现数据选择功能的逻辑电路。它的作用相当于多个输入的单刀多掷开关，又称“多路开关” 。 数据选择的功能：在通道选择信号的作用下，将多个通道的数据分时传送到公共的数据通道上去的。 4.4.3.1 2选1数据选择器 4.4.3.2 4选1数据选择器 4.4.3.3 8选1数据选择器(74HC151) Info\rL是低电平。 H是高电平。\r4.4.3.4 数据选择器构成查找表LUT 4.4.3.5 利用数据选择器实现函数的一般步骤:（变量数=选通端数） 将函数变换成最小项表达式 选择输入信号S2、S1、S0作为函数的输入变量 处理数据输入D0~D7信号电平。逻辑表达式中有$m_i$ ,则相应$D_i$ =1，其他的数据输入端均为0。当变量数\u003e选通端数，考虑如何将某些变量接入数据端。 ","date":"2023-01-14","objectID":"/math_electronic/:15:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.4 数值比较器 4.4.4.1 一位数值比较器 4.4.4.1.1 真值表 A B $F_{A\u003eB}$ $F_{A=B}$ $F_{A\u003cB}$ 0 0 0 0 1 0 1 0 1 0 1 0 1 0 0 1 1 0 0 1 4.4.4.1.2 表达式 $$ F_{A\u003eB}=A\\overline{B} $$ $$ F_{A\u003cB}=\\overline{A}B $$ $$ F_{A=B}=A\\odot B $$ 4.4.4.1.3 逻辑图 4.4.4.2 两位数值比较器 4.4.4.2.1 真值表 A1 B1 A0 B0 $F_{A\u003eB}$ $F_{A\u003cB}$ $F_{A=B}$ A1\u003eB1 X 1 0 0 A1\u003cB1 X 0 1 0 A1=B1 A0\u003eB0 1 0 0 A1=B1 A0=B0 0 0 1 A1=B1 A0\u003cB0 0 1 0 4.4.4.2.2 表达式 $$ F_{A\u003eB}=F_{A1\u003eB1}+F_{A1=B1} \\cdot F_{A0\u003eB0} $$ $$ F_{A\u003cB}=F_{A1\u003cB1}+F_{A1=B1} \\cdot F_{A0\u003cB0} $$ $$ F_{A=B}=F_{A1=B1} \\cdot F_{A0=B0} $$ 4.4.4.2.3 逻辑图 4.4.4.3 四位数据比较器 原理和二位比较器相同，从最高位到最低位一次比较。 74HC85还有3个拓展输入端:$ I_{A\u003eB},I_{A\u003cB},I_{A=B} $,可以与低位输出连接组成位数更多的比较器。 ","date":"2023-01-14","objectID":"/math_electronic/:15:4","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.4.4 拓展 4.4.4.4.1 串联 有I端 先对低位进行比较，将比较结果输给高位的I端。再在高位进行比较。 无I端 4.4.4.4.2 并联 ","date":"2023-01-14","objectID":"/math_electronic/:15:5","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.4.5 算术运算电路 4.4.5.1 半加器 只考虑了两个加数本身，而没有考虑低位进位的加法运算叫做半加。 4.4.5.1.1 真值表 A B C S 0 0 0 0 0 1 0 1 1 0 0 1 1 1 1 0 4.4.5.1.2 表达式 $$ S=A\\oplus B $$ $$ C=AB $$ 4.4.5.1.3 逻辑图 4.4.5.2 全加器 4.4.5.2.1 真值表 A B $C_i$ S $C_O$ 0 0 0 0 0 0 0 1 1 0 0 1 0 1 0 0 1 1 0 1 1 0 0 1 0 1 0 1 0 1 1 1 0 0 1 1 1 1 1 1 4.4.5.2.2 表达式 $$ S=A\\oplus B \\oplus C_i $$ $$ C_o=AB+(A\\oplus B)C_i $$ 4.4.5.2.3 逻辑图 4.4.5.3 串行进位多位加法器 4.4.5.4 减法器 ","date":"2023-01-14","objectID":"/math_electronic/:15:6","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6 组合逻辑电路的行为级建模 ","date":"2023-01-14","objectID":"/math_electronic/:16:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6.1 if-else语句 module chooser_4(S,D,Y); input [1:0]S; input [3:0]D; output reg Y; always@(D,S) begin if(S==2'b00) Y=D[0]; else if(S==2'b01) Y=D[1]; else if(S==2'b10) Y=D[2]; else Y=D[3]; end endmodule Warning\r注意，过程赋值语句只能给寄存器型变量赋值，因此，输出变量Y的数据类型定义为reg。\r","date":"2023-01-14","objectID":"/math_electronic/:16:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6.2 case语句 Info\r用关键词casex和casez表示含有无关项x和高阻z的情况。\rWarning\r当分支项中的语句是多条语句，必须在最前面写上关键词begin，在最后写上关键词end，成为顺序语句块。\r4.6.2.1 对具有使能端$E_n$的4选1数据选择器行为进行Verilog描述。当$E_n$=0时，数据选择器工作，$E_n$=1时，禁止工作，输出为0。 module choose_4(S,D,Y,E); input [1:0] S; input [3:0] D; output reg Y; input E; always@(S,D,E) begin if(E==1'b1) begin case(S) 2'b00:Y\u003c=D[0]; 2'b01:Y\u003c=D[1]; 2'b10:Y\u003c=D[2]; 2'b11:Y\u003c=D[3]; endcase end else Y\u003c=1'b0 end endmodule 4.6.2.2 对基本的4线-2线优先编码器的行为进行Verilog描述。 module coder_4_2(I,Y); input [3:0]I; output reg[1:0]Y; always@(I) begin casex(I) 4'b1xxx:Y\u003c=2'b11; 4'b01xx:Y\u003c=2'b10; 4'b001x:Y\u003c=2'b01; 4'b0001:Y\u003c=2'b00; default:Y\u003c=2'bx; endcase end endmodule ","date":"2023-01-14","objectID":"/math_electronic/:16:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6.3 for语句 试用Verilog语言描述具有高电平使能的3线-8线译码器. module trans_3_8(I,Y,E); input [2:0]I; input E; output reg[7:0]Y; integar k; always@(I,E) begin Y=8'b1111_1111; for(k=0;k\u003c8;k=k+1) begin if(k==I\u0026\u0026E) Y[k]=0; else Y[k]=1; end end endmodule ","date":"2023-01-14","objectID":"/math_electronic/:16:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6.4 条件运算符 例：用条件运算符描述了一个2选1的数据选择器 module chooser_2_1( input [1:0]D; input sel; output reg Y; ); always@(D,sel) begin Y\u003c=sel?D[1]:D[0]; end endmodule module choose_2_1( input [1:0]D; input sel; output Y; ); assign Y\u003c=sel?D[1]:D[0]; endmodule ","date":"2023-01-14","objectID":"/math_electronic/:16:4","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"4.6.5 模块化设计方法 分层次的电路设计:在电路设计中，将两个或多个模块组合起来描述电路逻辑功能的设计方法。 设计方法：自顶向下和自底向上两种常用的设计方法。 4.6.5.1 四位全加器 4.6.5.1.1 半加器 module half_adder(A,B,S,C); input A,B; output reg S,C; always@(A,B) begin S\u003c=A^B; C\u003c=A\u0026B; end endmodule 4.6.5.1.2 全加器 module full_adder(A,B,Ci,S,C0); input A,B,Ci; output S,C0; wire S1,D1,D2; half_adder HA1(A,B,S1,D1); half_adder HA2(S1,Ci,S,D2); or(C0,D1,D2); endmodule 4.6.5.1.3 四位全加器 module adder_4_dig( input [3:0]A,B; input CI; output [3:0]S, output CO ) wire [2:0]C; full_adder fa0(A[0],B[0],CI,S[0],C[0]); full_adder fa1(A[1],B[1],C[0],S[1],C[1]); full_adder fa2(A[2],B[2],C[1],S[2],C[2]); full_adder fa3(A[3],B[3],C[2],S[3],CO); endmodule 5 锁存器和触发器 ","date":"2023-01-14","objectID":"/math_electronic/:16:5","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.1 双稳态电路 ","date":"2023-01-14","objectID":"/math_electronic/:17:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.1.1 基本的双稳态电路 双稳态电路是锁存器和触发器的结构组成、功能实现的基础. ","date":"2023-01-14","objectID":"/math_electronic/:17:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.2 SR锁存器 ","date":"2023-01-14","objectID":"/math_electronic/:18:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.2.1 基本SR锁存器 5.2.1.1 工作原理 5.2.1.2 真值表 5.2.1.3 变种 5.2.1.4 规律 5.2.1.5 运用 运用基本SR锁存器消除机械开关触点抖动引起的脉冲输出。 ","date":"2023-01-14","objectID":"/math_electronic/:18:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.2.2 门控SR锁存器 ","date":"2023-01-14","objectID":"/math_electronic/:18:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.3 D锁存器 ","date":"2023-01-14","objectID":"/math_electronic/:19:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.3.1 电路结构 Info\r没有圆圈的一侧是高电平的时候TG就是通路。\r","date":"2023-01-14","objectID":"/math_electronic/:19:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.3.2 逻辑功能 ","date":"2023-01-14","objectID":"/math_electronic/:19:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.4 触发器的电路结构和工作原理 Tip\r在逻辑图中触发器的时钟信号接口处有三角\r共同点： 具有0 和1两个稳定状态，一旦状态被确定，就能自行保持。一个锁存器或触发器能存储一位二进制码。 不同点： 锁存器—对脉冲电平敏感的存储电路，在特定输入脉冲电平作用下改变状态。 触发器—对脉冲边沿敏感的存储电路，在时钟脉冲的上升沿或下降沿的变化瞬间改变状态 ","date":"2023-01-14","objectID":"/math_electronic/:20:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.4.1 D触发器 5.4.1.1 电路结构 两个D锁存器级联构成一个主从D触发器 主锁存器与从锁存器结构相同(但使能信号相反) TG1和TG4的工作状态相同 TG2和TG3的工作状态相同 5.4.1.2 D触发器工作原理 CP=0时： TG1导通，TG2断开——输入信号D 送入主锁存器。 Q’跟随D端的状态变化，使Q’=D TG3断开，TG4导通——从锁存器维持在原来的状态不变。 CP=1时： TG1断开，TG2导通——输入信号D 不能送入主锁存器。主锁存器维持原态不变。 TG3导通，TG4断开——主锁存器Q’的信号送从锁存器Q端。使Q=D。 触发器的状态仅仅取决于CP信号上升沿到达前瞬间的D信号！ 5.4.1.2.1 特性表 D $Q_n$ $Q_{n+1}$ 0 0 0 0 1 0 1 0 1 1 1 1 5.4.1.2.2 特性方程 $$ Q^{n+1} = D $$ 5.4.1.2.3 状态图 ","date":"2023-01-14","objectID":"/math_electronic/:20:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.4.2 JK触发器 Tip\r本质上JK触发器就是升级版的SR触发器，多了个翻转功能。\r5.4.2.1 工作原理 5.4.2.1.1 特性表 J K $Q_n$ $Q_{n+1}$ 说明 0 0 0 0 保持 0 0 1 1 保持 0 1 0 0 置0 0 1 1 0 置0 1 0 0 1 置1 1 0 1 1 置1 1 1 0 1 翻转 1 1 1 0 翻转 5.4.2.1.2 特性方程 $$ Q_{n+1} = J\\overline{ Q_{n} } + \\overline{K}Q_{n} $$ 5.4.2.1.2 状态转移图 ","date":"2023-01-14","objectID":"/math_electronic/:20:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.4.3 T触发器 5.4.3.1 工作原理 5.4.3.1.1 特性表 T Qn Qn+1 0 0 0 0 1 1 1 0 1 1 1 0 5.4.3.1.2 特性方程 $$ Q_{n+1} = T\\overline{ Q_{n} } + \\overline{T}Q_{n} $$ 5.4.3.1.3 状态转移图 ","date":"2023-01-14","objectID":"/math_electronic/:20:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.4.4 SR触发器 5.4.4.1 特性表 Qn S R Qn+1 0 0 0 0 1 0 0 1 0 0 1 0 1 0 1 0 0 1 0 1 1 1 0 1 0 1 1 x 1 1 1 x 5.4.4.2 特性方程 $$Q_{n+1} = S + R\\overline{ Q_{n} }$$ $$ SR = 0 $$ 5.4.4.3 状态转移图 ","date":"2023-01-14","objectID":"/math_electronic/:20:4","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.5 D触发器转换 ","date":"2023-01-14","objectID":"/math_electronic/:21:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.5.1 D触发器构成JK触发器 ","date":"2023-01-14","objectID":"/math_electronic/:21:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"5.5.2 D触发器构成T触发器 6 时序逻辑电路 时序逻辑电路的工作特点是任意时刻的输出状态不仅与该当前的输入信号有关，而且与此前电路的状态有关。 ","date":"2023-01-14","objectID":"/math_electronic/:21:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.1 时序逻辑电路的基本概念 ","date":"2023-01-14","objectID":"/math_electronic/:22:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.1.1 时序逻辑电路的模型与分类 6.1.1.1 时序电路的基本结构 6.1.1.2 时序逻辑电路的分类 按状态变化分类： 同步时序电路:电路状态的变化在同一时钟脉冲作用下发生，即存储电路里所有触发器有一个统一的时钟源，它们的状态在同一时刻更新。 异步时序电路:没有统一的时钟脉冲或没有时钟脉冲，电路的状态更新不是同时发生的。 按输出信号分类： 米利（Mealy）型时序电路:电路的输出是输入变量及触发器输出Q1、Q0 的函数，这类时序电路亦称为米利型电路 穆尔（ Moore）型时序电路:电路输出仅仅取决于各触发器的状态，而不受电路当时的输入信号影响或没有输入变量，这类电路称为穆尔型电路 ","date":"2023-01-14","objectID":"/math_electronic/:22:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.2 同步 时序逻辑电路的分析 ","date":"2023-01-14","objectID":"/math_electronic/:23:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.2.1 逻辑方程组 输出方程: $O＝f_1(I,S)$ 表达输出信号与输入信号、状态变量的关系式 激励方程: $E＝f_2(I,S)$ 表达了激励信号与输入信号、状态变量的关系式 状态方程: $S^{n+1}＝f_3(E,S^n)$ 表达存储电路从现态到次态的转换关系式 Note\r状态方程是由激励方程和所用的触发器的类型决定的\r6.2.2 表达过程 列出逻辑方程组 根据方程组列出状态转换真值表 将状态转换真值表化为转换表 根据转换表得状态表 根据状态表画状态转移图 6.2.2.1 例 列出逻辑方程组： 输出方程：$$X = Q_0\\overline{ Q_1 }$$ $$Y = \\overline{A} ( Q_0 + Q_1 ) $$ 激励方程：$$ D_0 = A ( Q_0 + Q_1 ) $$ $$ D_1 = A \\overline{Q_0} $$ 状态方程： $$ Q^{n+1}_{0} = A ( Q^{n}_0 + Q^{n}_1 ) $$ $$ Q_{1}^{n+1} = A \\overline{ Q_{0}^{n} } $$ 根据方程组列出状态转换真值表: A $Q_0^n$ $Q_1^n$ $Q_0^{n+1}$ $Q_1^{n+1}$ X Y 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 1 0 0 0 1 1 0 1 1 0 0 0 1 1 0 0 0 1 0 0 1 0 1 1 1 0 0 1 1 0 1 0 1 0 1 1 1 1 0 0 0 将状态转换真值表化为转换表 根据转换表得状态表 令$S^n$为$Q_0^nQ_1^n$，$S^{n+1}$为$Q_0^{n+1}Q_0^{n+1}$，4个状态为00=a，01=b，10=c，11=d，得： 根据状态表画状态转移图 ","date":"2023-01-14","objectID":"/math_electronic/:23:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.3 同步 时序逻辑电路的设计 Note\r同步时序逻辑电路的设计是分析的逆过程,其任务是根据实际逻辑问题的要求，设计出能实现给定逻辑功能的电路。\r","date":"2023-01-14","objectID":"/math_electronic/:24:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.3.1 设计同步时序逻辑电路的一般步骤 6.3.1.1 根据给定的逻辑功能建立原始状态图和原始状态表 明确电路的输入条件和相应的输出要求，分别确定输入变量和输出变量的数目和符号。 找出所有可能的状态和状态转换之间的关系。 根据原始状态图建立原始状态表。 6.3.1.2 状态化简—–求出最简状态图 合并等价状态，消去多余状态的过程称为状态化简 Info\r等价状态：在相同的输入下有相同的输出，并转换到同一个次态去的两个状态称为等价状态。\r6.3.1.3 状态编码（状态分配） 给每个状态赋以二进制代码的过程。 $2^{n-1}$ \u003c M $\\leq 2^n$ （M:状态数;n:触发器的个数） Info\r状态编码的位数即为触发器的个数\r6.3.1.4 选择触发器的类型 6.3.1.5 求出电路的激励方程和输出方程 6.3.1.6 画出逻辑图并检查自启动能力 ","date":"2023-01-14","objectID":"/math_electronic/:24:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.5 若干典型的时序逻辑电路 ","date":"2023-01-14","objectID":"/math_electronic/:25:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.5.1 寄存器和移位寄存器 在数字电路系统中，把需要处理的二进制数据或代码暂时存储起来，以便在需要的时候随时取用，这样的操作叫做寄存 6.5.1.1 8位CMOS寄存器74HC374 6.5.1.2 移位寄存器 移位寄存器是既能寄存数码，又能在时钟脉冲的作用下使数码在高低位之间移动的逻辑功能部件。 6.5.1.2.1 基本移位寄存器 6.5.1.2.2 多功能双向移位寄存器 ","date":"2023-01-14","objectID":"/math_electronic/:25:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.5.2 计数器 计数器的基本功能是对输入时钟脉冲进行计数。它也可用于分频、定时、产生节拍脉冲和脉冲序列及进行数字运算等等。 6.5.2.1 二进制计数器 Note\r$Q_0$在每个CP都翻转一次，$FF_0$可采用T=1的T触发器。 $Q_1$仅在$Q_0$=1后的下一个CP到来时翻转，$FF_1$可采用T= $Q_0$的T触发器。 $Q_2$仅在$Q_0$=$Q_1$=1后的下一个CP到来时翻转。$FF_2$可采用T= $Q_0Q_1$的T触发器。 $Q_3$仅在$Q_0$=$Q_1$=$Q_2$=1后的下一个CP到来时翻转。$FF_3$可采用T= $Q_0Q_1Q_2$的T触发器。\r6.5.2.1.1 74LVC161 Info\r一个变量与0异或等于本身，与1异或等于它的取反。\r用74LVC161构成九进制加计数器: 反馈清零法：利用异步置零输入端，在M进制计数器的计数过程中，跳过M-N个状态，得到N进制计数器的方法。 反馈置数法:利用同步置数端，在M进制计数器的计数过程中，跳过M-N个状态，得到N进制计数器的方法。 用74VC161组成256进制计数器: 并行进位：低位片的进位作为高位片的使能 串行进位：低位片的进位作为高位片的时钟 Info\r如果不加反相器，00001110的下个状态不再是00001111而是00011111。加了反相器使得00001110的下个状态时00001111，然后00001111的下个状态是00010000。\r","date":"2023-01-14","objectID":"/math_electronic/:25:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.7 用Verilog HDL描述时序逻辑电路 ","date":"2023-01-14","objectID":"/math_electronic/:26:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.7.1 移位寄存器 用行为级描述always描述一个４位双向移位寄存器，有异步清零、同步置数、左移、右移和保持。功能同74HC194。 module reg4(clk,clr,S,data,left0,right0,en,Q); input clk,clr,left0,right0,en; input [1:0] S; input [3:0] data; output reg [3:0] Q; always@(posedge clk or posedge clr) begin if(clr) Q\u003c=4'b0000; else if(en) begin case(S) 2'b00: Q\u003c=Q; 2'b01: Q\u003c={Q[2:0],right0}; 2'b10: Q\u003c={left0,Q[3:1]}; 2'b11: Q\u003c=data; endcase end end endmodule ","date":"2023-01-14","objectID":"/math_electronic/:26:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.7.2 计数器 用Verilog描述带使能端和同步置数端的可逆4位二进制计数器 module counter(clk,en,set,data,Q,flag); input en,set,flag; input [3:0] data; output reg [3:0] Q; always@(posedge clk) begin if(!en) Q\u003c=Q; else if(set) Q\u003c=data; else if(flag==1) Q\u003c=Q+1; else Q\u003c=Q-1; end endmodule ","date":"2023-01-14","objectID":"/math_electronic/:26:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"6.7.3 状态转换图 module loop(A,Y,clk,clr); parameter S0=2'b00,S1=2'b01,S2=2'b11; input A,clk; reg [1:0] cur,next; output reg Y; always@(posedge clk,negedge clr) begin if(clr) cur\u003c=S0; else if(clk) cur\u003c=next; end always@(posedge clk) begin Y\u003c=0; case(cur) S0: next\u003c=A?S1:S2; S1: next\u003c=A?S0:S2; S2: if(A) next\u003c=S2; else begin next\u003c=S0;Y\u003c=1; default: next\u003c=S0; endcase end endmodule 7 半导体存储器 ","date":"2023-01-14","objectID":"/math_electronic/:26:3","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"7.1 只读存储器 (ROM） ROM是一种永久性数据存储器，其中的数据一般由专用的装置写入，数据一旦写入，不能随意改写，在切断电源之后，数据也不会消失。 ROM主要由地址译码器、存储矩阵和输出控制电路三部分组成。 ","date":"2023-01-14","objectID":"/math_electronic/:27:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"7.1.1 基本概念 存储容量（M)：存储单元的数目。 字：存储器中作为一个整体被存取传送处理的一组数据 。 字长：一个字所含的位数称为字长。 字数：字的总量。 地址线个数/地址码位数n：字数=$2^n$ 数据位数=位数。 例：容量为64K ×1的存储系统有多少个存储单元？其地址码需要几位？数据位是几位？ 存储单元数=字数×位数=64K×1=64K个=$2^{16}$个 地址线数： 因为字数为64K=$2^{16}$个，即n=16，所以地址线数为16位而数据线数等于位数，故数据线为1位 Info\r1K=1024=$2^{10}$ 1M=1024K=$2^{20}$ 1G=1024M=$2^{30}$\r","date":"2023-01-14","objectID":"/math_electronic/:27:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"7.2 随机存取存储器 (RAM) 在正常工作状态只能读出信息。断电后信息不会丢失，常用于存放固定信息(如程序、常数等)。 ","date":"2023-01-14","objectID":"/math_electronic/:28:0","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"7.2.1 静态随机存取存储器(SRAM) ","date":"2023-01-14","objectID":"/math_electronic/:28:1","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":["college"],"content":"7.2.3 动态随机存取存储器(DRAM) 7.2.3.1 写操作 X=1 $\\overline{WE}$=0 T导通，电容器C与位线B连通。 输入缓冲器被选通，数据$D_I$经缓冲器和位线写入存储单元如果$D_I$为1，则向电容器充电，C存1;反之电容器放电,C存0 。 7.2.3.2 读操作 X=1 $\\overline{WE}$=1 T导通，电容器C与位线B连通 输出缓冲器/灵敏放大器被选通，C中存储的数据通过位线和缓冲器由D0输出 每次读出后，必须及时对读出单元刷新，即此时刷新控制R也为高电平，则读出的数据又经刷新缓冲器和位线对电容器C进行刷新。 ","date":"2023-01-14","objectID":"/math_electronic/:28:2","tags":null,"title":"数字电子技术理论笔记","uri":"/math_electronic/"},{"categories":null,"content":" Hello World! ","date":"2023-01-11","objectID":"/about/:0:0","tags":null,"title":"Welcome to my Blog!","uri":"/about/"},{"categories":null,"content":"Thanks for these friends 😍 ! SuperSASS\rMy mentor\r","date":"2023-01-11","objectID":"/about/:1:0","tags":null,"title":"Welcome to my Blog!","uri":"/about/"},{"categories":null,"content":"Who Am I I am particularly interested in Roman history,in which Caesar Augustus is my favorite character.I was born in September,so i named myself as Septemus.I’m just a college student and i use this site to keep my notes,that’s all. ","date":"2023-01-11","objectID":"/about/:2:0","tags":null,"title":"Welcome to my Blog!","uri":"/about/"},{"categories":null,"content":"How Old Is This Blog? 🤗 Loading days… Loading secs… ","date":"2023-01-11","objectID":"/about/:3:0","tags":null,"title":"Welcome to my Blog!","uri":"/about/"},{"categories":["Projects"],"content":"\rWarning\r此项目成员均为学生，还在开发过程中，因此相比企业级项目而言页面简陋技术落后，望看到这篇文章的高手轻喷。并且如果发现BUG或有改进建议，欢迎和我联系！\r","date":"2023-01-09","objectID":"/webrtc_communication/:0:0","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"摘要 本课题拟重点关注应急通信的需求，在临时搭建的局域网通信环境下，设计与开发适用于手机、平板和电脑的音视频即时聊天工具，包括客户端和服务器软件，实现无互联网环境下的局域网即时通信功能。 以下是本课题所用到的技术： HTML CSS Javascript Electron Cordova nodejs Github源代码： ","date":"2023-01-09","objectID":"/webrtc_communication/:1:0","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"模块介绍 ","date":"2023-01-09","objectID":"/webrtc_communication/:2:0","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"主服务器端 前端 前端页面的设计包括HTML+CSS的网页展示模块以及基于JavaScript前端脚本模块。 其中，前端脚本模块所做的工作如下： 利用DOM操作获取到网页中输入框的内容，并进行初步的模式匹配，以防止不合法的输入出现。 利用Ajax机制进行前后端数据通信，通过访问后端服务器所提供的接口URL来进行相关的注册、登录、信息修改以及网页跳转的工作。 在获得了后端服务器发来的成功登录的信息后，将报文中的token保存在浏览器本地的sessionStorage中，并在后续的每次访问中携带该token。 后端 后端需要引入数据库模块用于记录用户的注册信息。在本项目中使用了MySQL关系型数据库，用过JavaScript操作SQL语句进行数据的增、删、查、改操作。 服务器对外提供了登录、注册、用户信息修改的接口，以登录接口为例，登录接口的URL地址如下：http://服务器IP:服务端口号/api/login 后端提供登录、注册、信息增删的服务之前需要采取如下操作： 利用开源的joi模块进行前端所发来的数据的模式识别，以防止不合法的输入被传入数据库。 若因为注册、信息修改等操作导致用户密码被设置或修改，需要利用开源的bscryptjs模块对密码进行加密后再写入数据库，以防止泄密。在每次登录时，需要将从数据库中取出的密码解密后再与前端所发来的密码比对。 在验证用户信息后，主服务器会依据从数据库中获取到的用户信息，利用开源的jsonwebtoken模块生成一个JSON格式的token串，并将该token串以及相应的信息传输给前端，随后前端的每次带权限的请求（如获取WebRTC即时音视频服务、访问主页等）都需要携带此token，后端验证token通过后才提供相应的服务。 此外，服务器需要将前端页面所需要的所有HTML以及相关的CSS样式、JavaScript脚本文件设置成静态资源以方面用户进行访问。 ","date":"2023-01-09","objectID":"/webrtc_communication/:2:1","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"信令服务器端 WebRTC开发环境搭建 WebRTC目前已经被Trident、Chromium、Webkit等多种浏览器内核所支持，具有很高的兼容性，不需要额外的下载外部模块。但是，如表4-1所示，由于不同厂商在开发WebRTC项目时对同一个接口采用了不同的接口名，不同的浏览器在运行同一个WebRTC应用时可能会出现接口不适配的问题。 WebRTC标准 Chrome Firefox getUserMedia webkitGetUserMedia getUserMedia RTCPeerConnection webkitRTCPeerConnection RTCPeerConnection RTCsessionDescription RTCsessionDescription RTCsessionDescription RTCIceCandidate RTCIceCandidate RTCIceCandidate 因此，需要采用WebRTC官方提供的适配器adapter-latest.js文件才能解决如上的兼容性问题。该兼容性解决方案需要在渲染页面时引入，即在即时通话的HTML页面中使用\u003cscript src=\"adapter-latest.js\"\u003e\u003c/script\u003e语句引入适配器文件。 信令服务器端 服务器使用app.use(express.static(path.join(__dirname, ‘../public’)))语句将对外提供的HTML、CSS以及JavaScript脚本文件设置为静态资源，客户端可以通过URL来访问这些资源以获取即时通信服务。其中，app为信令服务器所创建的HTTPS服务器实例，‘public’为存放客户端文件的目录。 服务器在获取到客户端的URL后，根据URL中携带的jwt token字符进行身份校验，若token验证通过才将URL对应的资源页面提供给客户端，否则，拒绝这次请求。 使用socket.io技术实时监听客户端所发来的数据，以协助通信双方的信令交互。 服务器的处理流程如下图所示： 浏览器前端 浏览器前端的所需要完成功能则相对较多，包括获取音视频流、协商通信配置、建立P2P连接等，按照顺序可以分为以下几个步骤： 获取客户端本地的音视频流 由于针对不同的客户端以及浏览器会有不同的硬件设备，需要为这些不同的设备或浏览器提供兼容性的解决方案，因此需要引入由WebRTC官方提供的适配器模块 adapter.js。随后通过getUserMedia函数获取音视频流。 建立PeerConnection对象 在客户端的JavaScript脚本内创建PeerConnection，由于创建、协调并维持通信双方的连接。随后，将PeerConnection的ontrack成员方法与远程视频流绑定，将 PeerConnection的addStream成员方法与本地视频流绑定。 加入房间 在访问即时音视频通信服务中，会在get请求中附带room参数，在成功获取到服务后，前端会向信令服务器使用socket.io的emit函数发送一个名为rooms的事件，事 件携带的数据为get请求中room的参数。 服务器监听到rooms事件后，会将该客户加入值为room的房间，随后，该客户的所有信令信息仅在值为room的房间中转发。 协商会话描述配置 受限于通信双方的硬件设置等因素的影响，在正式通信之前通信双方需要协商通信的配置信息。主叫向被叫发送PeerConnection的成员变量 localDescription，被 叫通过使用PeerConnection的成员方法setRemoteDescription来实现主叫与被叫之间的会话描述配置。 客户端通过socket.io的emit函数发送一个名为message的事件，事件携带的参数为localDescription。 协商连接双方的网络信息 由于通信双方可能处于NAT网络之后，需要通过ICE服务器提供的内网穿透服务才能正式建立连接，因此通信双方之间需要发送RTCIceCandidate这一对象，该对象包 含的属性包括本地IP地址、公网IP地址等等所有相关网络配置信息。 该配置信息的发送是基于socke.io发送的名为message的事件来实现。 建立P2P连接 主叫通过调用PeerConnection的成员方法createOffer向被叫发起建立连接请求，被叫收到请求后可以拒绝这个请求或调用PeerConnection的成员方法createAnswer 来响应这个请求。 主叫与被叫所发送的信息都是基于socket.io的emit函数来发送一个名为message的事件。 ","date":"2023-01-09","objectID":"/webrtc_communication/:2:2","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"移动端 由于项目基于web开发，所以选择cordova框架进行打包移植。打包的流程大致如下： 相关的环境配置 创造cordova项目 在项目中添加移动端平台 将前端页面文件移入www文件夹 将页面布局调整以适应手机大小 在config.xml中修改权限解决跨域问题 生成app 后续实机调试 ","date":"2023-01-09","objectID":"/webrtc_communication/:2:3","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"核心代码 ","date":"2023-01-09","objectID":"/webrtc_communication/:3:0","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"注册和登录 前端 为按钮绑定ajax事件将用户输入的信息传到后端，根据后端返回信息决定下一步。 自动获取ip地址： var ip window.RTCPeerConnection = window.RTCPeerConnection || window.mozRTCPeerConnection || window.webkitRTCPeerConnection; //compatibility for Firefox and chrome if (!RTCPeerConnection) { let win = iframe.contentWindow; RTCPeerConnection = win.RTCPeerConnection || win.mozRTCPeerConnection || win.webkitRTCPeerConnection; } var pc = new RTCPeerConnection({iceServers:[]}), noop = function(){}; pc.createDataChannel(''); //create a bogus data channel pc.createOffer(pc.setLocalDescription.bind(pc), noop); // create offer and set local description pc.onicecandidate = function(ice){ if (ice \u0026\u0026 ice.candidate \u0026\u0026 ice.candidate.candidate){ ip = /([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(ice.candidate.candidate)[1]; console.log('my IP: ', ip); pc.onicecandidate = noop; } }; try{ if(!ip) ip=/([0-9]{1,3}(\\.[0-9]{1,3}){3}|[a-f0-9]{1,4}(:[a-f0-9]{1,4}){7})/.exec(window.location.href)[1] }catch(err){ ip='localhost' } let login_btn = document.getElementById('login_btn'); let id = document.getElementById('id'); let password = document.getElementById('password'); $('#login_btn').on('click', function () { var params = 'id=' + id.value + '\u0026password=' + password.value; console.log(\"clicked login\") $.ajax({ type: 'post', url: 'http://' + ip + ':3007/api/login', contentType: 'application/x-www-form-urlencoded', data: params, success: function (result) { window.localStorage.setItem(result.id, result.id); sessionStorage.name = result.name; sessionStorage.id = result.id; sessionStorage.serverIP = result.serverIP; if (result.status === 0) { alert(\"登录成功,跳转至主界面\"); window.location.href = \"./HomePage.html\"; } else alert(result.message); } }) }) let register = document.getElementById('register'); let Rid = document.getElementById('Rid'); let Rname = document.getElementById('Rname'); let Rpassword = document.getElementById('Rpassword'); $('#register').on('click',function () { var params = \"id=\" + Rid.value + \"\u0026password=\" + Rpassword.value + \"\u0026name=\" + Rname.value; console.log(params) console.log('http://' + ip + ':3007/api/reguser') $.ajax({ type: 'post', url: 'http://' + ip + ':3007/api/reguser', contentType: 'application/x-www-form-urlencoded', data: params, }).then(result =\u003e { if (result.status === 0) { alert(\"注册成功,点击回到登陆界面\"); window.location.reload() } else { alert(result.message); } }) .catch(err=\u003e{ console.log(\"failure:\",err) alert('something wrong') }) }) 后端 在数据库中检索用户输入信息并执行相关操作 exports.regUser = (req, res) =\u003e { // 获取客户端提交到服务器的用户信息 const userinfo = req.body; // 定义 SQL 语句，查询用户名是否被占用 const sqlStr = 'select * from users where id=?'; db.query(sqlStr, userinfo.id, (err, results) =\u003e { // 执行 SQL 语句失败 if (err) { return res.cc(err); } // 判断用户名是否被占用 if (results.length \u003e 0) { return res.cc('用户名被占用，请更换其他用户名！', 2); } // 调用 bcrypt.hashSync() 对密码进行加密 userinfo.password = bcrypt.hashSync(userinfo.password, 10); // 定义插入新用户的 SQL 语句 const sql = 'insert into users set ?'; // 调用 db.query() 执行 SQL 语句 db.query(sql, { id: userinfo.id, password: userinfo.password, name: userinfo.name }, (err, results) =\u003e { // 判断 SQL 语句是否执行成功 // if (err) return res.send({ status: 1, message: err.message }) if (err) return res.cc(err); // 判断影响行数是否为 1 if (results.affectedRows !== 1) return res.cc('注册用户失败，请稍后再试！', 1); // 注册用户成功 res.cc('注册成功！', 0, 'http://' + ip + ':3007'); }) }) } // 登录的处理函数 exports.login = (req, res) =\u003e { console.log(\"login post received!\") const userinfo = req.body; console.log(userinfo) const sql = 'select * from users where id = ?'; db.query(sql, userinfo.id, (err, results) =\u003e { if (err) { console.log(\"error!\") return res.cc(err); } if (results.length !== 1) return res.cc('登陆失败'); //比较密码是否正确 const compare = bcrypt.compareSync(userinfo.password, results[0].password); if (!compare) return res.cc('密码输入错误'); //else return res.cc('登陆成功', 0); const user = { ...results[0], password: '', user_pic: '' };//...为展开运算符，将results[0]中所有元素赋给user //利用用户信息生成token const token = jwttoken.sign(user, jwtconfig.jwtSecr","date":"2023-01-09","objectID":"/webrtc_communication/:3:1","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"用户界面 通过socket实现用户列表的显示和更新 前端 var welcome = document.getElementById('welcome'); welcome.innerHTML = '欢迎 ' + sessionStorage.name; const socket = io(sessionStorage.serverIP + ':3007'); socket.on(\"connect\", () =\u003e { sessionStorage.socketID = socket.id; socket.emit('login', JSON.stringify({ 'id': sessionStorage.id, 'name': sessionStorage.name, 'sid': sessionStorage.socketID })); }); socket.on('called', (data) =\u003e { var info = JSON.parse(data); if (info.calledID == sessionStorage.id) { window.blur(); setTimeout(window.focus(), 100); var r = window.confirm('您正在被' + info.callingID + '呼叫！'); if (r == false) { socket.emit('refuse', JSON.stringify({ 'name': sessionStorage.name, 'callingSid': info.callingSid })); } else { window.open('https://' + sessionStorage.serverIP + ':8443/index.html?room=' + info.callingID+'\u0026id='+sessionStorage.id); socket.emit('agree', info.callingSid); } } }) socket.on('refuse', (data) =\u003e { alert(data + '拒绝了您的通话请求！'); }); socket.on('agree', () =\u003e { console.log(1); window.open('https://' + sessionStorage.serverIP + ':8443/index.html?room=' + sessionStorage.id+'\u0026id='+sessionStorage.id); }) socket.on('joinroom',(data) =\u003e { var info = JSON.parse(data); // window.blur(); setTimeout(window.focus(), 100); // var r = window.confirm('您是否要加入' + info.roomid + '房间！'); window.open('https://' + sessionStorage.serverIP + ':8443/index2.html?name='+sessionStorage.name); //socket.emit('agree', info.callingSid); }) //const roomName = document.getElementById(\"roomName\"); // 房间号输入框 const joinRoom = document.getElementById(\"joinRoom\"); // 加入房间按钮 //console.log(sessionStorage.name); const socket = io(sessionStorage.serverIP + ':3007'); var table = document.getElementById('table'); socket.on('init', data =\u003e { for (var i = 0; i \u003c data.length; i++) { if (data[i].id != sessionStorage.id) { var tr = document.createElement('tr'); table.appendChild(tr); //创建Sid栏 var td_sid = document.createElement('td'); td_sid.innerHTML = data[i].sid; tr.appendChild(td_sid); //创建id栏 var td_id = document.createElement('td'); td_id.innerHTML = data[i].id; td_id.id = data[i].id; tr.appendChild(td_id); //创建name栏 var td_name = document.createElement('td'); td_name.innerHTML = data[i].name; tr.appendChild(td_name); //创建会话图标栏 var td_RTC = document.createElement('td'); //创建图标 var button = document.createElement('button'); button.addEventListener('click', () =\u003e { var data = JSON.stringify({ 'callingID': sessionStorage.id, 'calledID': td_id.id, 'callingSid': sessionStorage.socketID }); socket.emit('calling', data); }); var img = document.createElement('img'); img.setAttribute('src', '../assets/images/camera.webp'); img.setAttribute('height', '30px'); button.appendChild(img); tr.appendChild(button); } } }) socket.on('online', (data) =\u003e { var user = JSON.parse(data); if (user.id != sessionStorage.id) { //动态创建行 var tr = document.createElement('tr'); table.appendChild(tr); //创建Sid栏 var td_sid = document.createElement('td'); td_sid.innerHTML = user.sid; tr.appendChild(td_sid); //创建id栏 var td_id = document.createElement('td'); td_id.innerHTML = user.id; td_id.id = user.id; tr.appendChild(td_id); //创建name栏 var td_name = document.createElement('td'); td_name.innerHTML = user.name; tr.appendChild(td_name); //创建会话图标栏 var td_RTC = document.createElement('td'); //创建图标 var button = document.createElement('button'); button.addEventListener('click', () =\u003e { var data = JSON.stringify({ 'callingID': sessionStorage.id, 'calledID': td_id.id, 'callingSid': sessionStorage.socketID }); socket.emit('calling', data); }); var img = document.createElement('img'); img.setAttribute('src', '../assets/images/camera.webp'); img.setAttribute('height', '30px'); button.appendChild(img); tr.appendChild(button); } }); joinRoom.onclick = function () { //var data = JSON.stringify({ 'callingID': sessionStorage.id, 'callingSid': sessionStorage.socketID , 'roomid':roomName.value}); var data = JSON.stringify({ 'callingID': sessionStorage.id, 'callingSid': sessionStorage.socketID }); console.log(data); socket.emi","date":"2023-01-09","objectID":"/webrtc_communication/:3:2","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"通话页面 前端 创建房间页： const createButton = document.querySelector(\"#createroom\"); const videoCont = document.querySelector('.video-self'); const codeCont = document.querySelector('#roomcode'); const joinBut = document.querySelector('#joinroom'); const mic = document.querySelector('#mic'); const cam = document.querySelector('#webcam'); let micAllowed = 1; let camAllowed = 1; let mediaConstraints = { video: true, audio: true }; navigator.mediaDevices.getUserMedia(mediaConstraints).then(localstream =\u003e { videoCont.srcObject = localstream; }) // Generating room code function uuidv4() { return 'xxyxyxxyx'.replace(/[xy]/g, function (c) { var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r \u0026 0x3 | 0x8); return v.toString(16); }); } // Creating Room const createroomtext = 'Creating Room...'; createButton.addEventListener('click', (e) =\u003e { e.preventDefault(); createButton.disabled = true; createButton.innerHTML = 'Creating Room'; createButton.classList = 'createroom-clicked'; setInterval(() =\u003e { if (createButton.innerHTML \u003c createroomtext) { createButton.innerHTML = createroomtext.substring(0, createButton.innerHTML.length + 1); } else { createButton.innerHTML = createroomtext.substring(0, createButton.innerHTML.length - 3); } }, 500); location.href = `/room.html?room=${uuidv4()}\u0026name=${myname}`; }); // Joining Room joinBut.addEventListener('click', (e) =\u003e { e.preventDefault(); if (codeCont.value.trim() == \"\") { codeCont.classList.add('roomcode-error'); return; } const code = codeCont.value; location.href = `/room.html?room=${code}\u0026name=${myname}`; }) codeCont.addEventListener('change', (e) =\u003e { e.preventDefault(); if (codeCont.value.trim() !== \"\") { codeCont.classList.remove('roomcode-error'); return; } }) // Index page cam/audio cam.addEventListener('click', () =\u003e { if (camAllowed) { mediaConstraints = { video: false, audio: micAllowed ? true : false }; navigator.mediaDevices.getUserMedia(mediaConstraints) .then(localstream =\u003e { videoCont.srcObject = localstream; }) cam.classList = \"nodevice\"; cam.innerHTML = `\u003ci class=\"fas fa-video-slash\"\u003e\u003c/i\u003e`; camAllowed = 0; } else { mediaConstraints = { video: true, audio: micAllowed ? true : false }; navigator.mediaDevices.getUserMedia(mediaConstraints) .then(localstream =\u003e { videoCont.srcObject = localstream; }) cam.classList = \"device\"; cam.innerHTML = `\u003ci class=\"fas fa-video\"\u003e\u003c/i\u003e`; camAllowed = 1; } }) mic.addEventListener('click', () =\u003e { if (micAllowed) { mediaConstraints = { video: camAllowed ? true : false, audio: false }; navigator.mediaDevices.getUserMedia(mediaConstraints) .then(localstream =\u003e { videoCont.srcObject = localstream; }) mic.classList = \"nodevice\"; mic.innerHTML = `\u003ci class=\"fas fa-microphone-slash\"\u003e\u003c/i\u003e`; micAllowed = 0; } else { mediaConstraints = { video: camAllowed ? true : false, audio: true }; navigator.mediaDevices.getUserMedia(mediaConstraints) .then(localstream =\u003e { videoCont.srcObject = localstream; }) mic.innerHTML = `\u003ci class=\"fas fa-microphone\"\u003e\u003c/i\u003e`; mic.classList = \"device\"; micAllowed = 1; } }) // Index Clock function startTime() { const today = new Date(); let h = today.getHours(); let m = today.getMinutes(); let s = today.getSeconds(); m = checkTime(m); s = checkTime(s); document.querySelector('.index-time').innerHTML = h + \":\" + m + \":\" + s; setTimeout(startTime, 1000); } function checkTime(i) { if (i \u003c 10) { i = \"0\" + i }; // add zero in front of numbers \u003c 10 return i; } startTime(); 房间页面： const socket = io(); const overlayContainer = document.querySelector('#overlay') const continueButt = document.querySelector('.continue-name'); const nameField = document.querySelector('#name-field'); const chatRoom = document.querySelector('.chat-cont'); const sendButton = document.querySelector('.chat-send'); const messageField = document.querySelector('.chat-input'); const cutCall = document.querySelector('.cutcall'); let chatToggle = document.querySelector(\".chatting\"); // Room id const roomid = params.get(\"room\"); document.querySelector('.roomcode').innerHTML = `${roo","date":"2023-01-09","objectID":"/webrtc_communication/:3:3","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"成品效果 ","date":"2023-01-09","objectID":"/webrtc_communication/:4:0","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"pc端 ","date":"2023-01-09","objectID":"/webrtc_communication/:4:1","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["Projects"],"content":"移动端 ","date":"2023-01-09","objectID":"/webrtc_communication/:4:2","tags":null,"title":"基于局域网的音视频即时聊天客户端及服务器软件设计与开发","uri":"/webrtc_communication/"},{"categories":["college"],"content":"\rAttention\r由于2022年考核形式特殊，不具备普适性，本文对试卷原题略有修改，使其与一般情况下OJ模式吻合。\rWarning1\r本人能力有限，代码可能有错误。若读者发现欢迎联系我指出！\rWarning2\r机考和ACM、蓝桥杯之类的编程比赛有差别，不是通过了测试点就得分。改卷老师会参考代码的具体书写情况。极不推荐考生使用qsort、bsearch等库函数图方便！\r","date":"2022-09-12","objectID":"/jikao/:0:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"1.序列生成 ","date":"2022-09-12","objectID":"/jikao/:1:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"题目要求 写程序,在屏奉上打印出如下序列的前100项。(20 分) 序列的第一、二项分别为2和3: 序列后继项如下生成: 若序列的最后两项的乘积为一位数,则该一位数即为后续项: 若序列的最后两项的乘积为两位数,则该两位数的十位数字和个位数字分别为后续项的连续两项。 要求输出格式为\"%2d\",每行输出 10 个数,共10 行 解决思路：建立一个一位数组，从第三个元素开始遍历，每个元素的值都取决于前两个元素的乘积。 测试输入： 无 测试输出： 2 3 6 1 8 8 6 4 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 2 6 1 2 2 4 8 3 Source Code: #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #pragma warning(disable:4996) #define _for(a,b,c) for(a=b;a\u003cc;++a) int main(void) { int arr[105] = { 2,3 },i,t; _for(i, 2, 100) { t = arr[i - 1] * arr[i - 2]; if (t \u003c 10) arr[i] = t; else arr[i] = t / 10,arr[++i]=t%10; } _for(i, 1, 101) { printf(\"%2d\", arr[i - 1]); if ( !(i % 10)) putchar('\\n'); } return 0; } ","date":"2022-09-12","objectID":"/jikao/:1:1","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"2.字符串除重 ","date":"2022-09-12","objectID":"/jikao/:2:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"题目要求 从键盘输入一个字符串(长度不超过80个字符),将串中连续相同的字符只保留一个并生成新的字符串,最后输出生成的新字符串,要求定义函数 void cvt(char* s,char* t)实现操作输入输出格式 %s”。(20 分) 测试输入: aabbcccstbbbba 测试输出: abcstba 解决思路：定义前置字符ch=s[0],从i=1开始遍历，若s[i]!=ch则t的最后一项=s[i]同时ch=s[i]，否则略过 Source Code: #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cstring.h\u003e #pragma warning(disable:4996) #define _for(a,b,c) for(a=b;a\u003cc;++a) #define MAXN 85 void cvt(char* s, char* t); int main(void) { //freopen(\"d:\\\\test.txt\", \"r\", stdin); char str[2][MAXN] = { 0 }; scanf(\"%s\", str[0]); cvt(str[0], str[1]); printf(\"%s\", str[1]); return 0; } void cvt(char* s, char* t) { char ch =*(t++) =*(s++); while (*s) { if (ch != *s) { ch = *s; *(t++) = ch; } ++s; } } ","date":"2022-09-12","objectID":"/jikao/:2:1","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"3.矩阵排序 ","date":"2022-09-12","objectID":"/jikao/:3:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"题目要求 给定m行n列整数矩阵,编写函数,以该矩阵作为参数(假定m,n 己用define 定义为整型常量),实现如下要求:(20 分) 每行元素按由小到大顺序存储; 各行以第1列元素为关键字,按该关键字由小到大次序存储各行； 要求只写出函数(不要求实现矩阵的输入与输出),可以定义其它辅助函数。 示例矩阵:3-5 12 -7 函数处理后矩阵:19 0 5 5 8 2 10 6 153 12 49 550 2 68 10 测试输入: 无 测试输出: -9 0 5 5 -7 -5 3 12 -2 6 8 10 解决思路：先单独对数组的每一行排序，再根据每行首元素大小对行排序（通过交换两行中每个相同位置的元素实现行的交换）。 裁判程序: #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cstring.h\u003e #pragma warning(disable:4996) #define _for(a,b,c) for(a=b;a\u003cc;++a) #define m 3 #define n 4 void reshape(int matrix[m][n]); void prtma(int matrix[m][n]) { int i, j; _for(i, 0, m) { _for(j, 0, n) { printf(\"%2d\", matrix[i][j]); if (j \u003c n - 1) putchar(' '); else putchar('\\n'); } } } int main(void) { //freopen(\"d:\\\\test.txt\", \"r\", stdin); int matrix[m][n] = { 3,-5,12,-7,8,-2,10,6,-9,5,5,0 }; reshape(matrix); prtma(matrix); return 0; } //your source code here: Source Code: void reshape(int matrix[][n]) { int i,j,k; _for(k, 0, m) { _for(i, 1, n) { int t = matrix[k][i]; for (j = i - 1; j \u003e= 0; --j) { if (matrix[k][j] \u003e t) matrix[k][j + 1] = matrix[k][j]; else break; } matrix[k][j + 1] = t; } } _for(i, 1, m) { int t = matrix[i][0]; for (j = i - 1; j \u003e= 0; --j) { if (matrix[j][0] \u003e t) { int t1; _for(k, 0, n) { t1 = matrix[j][k]; matrix[j][k] = matrix[j + 1][k]; matrix[j + 1][k] = t1; } } else break; } } } ","date":"2022-09-12","objectID":"/jikao/:3:1","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"4.递归计算 ","date":"2022-09-12","objectID":"/jikao/:4:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"题目要求 给定自然数n,函数f(n)定义如下： f(0)=0, f(1)=1, f(2n)=f(n) f(2n+1)=f(n)+f(2n-1) 定义递归函数，计算f(n).(10分) 定义非递归函数，计算f(n).(10分) 测试输入： 1984 测试输出： 69 解决思路： 递归函数按照题目要求即可，非递归函数可建立一个数组从i=2开始递推。 裁判程序： #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cstring.h\u003e #pragma warning(disable:4996) #define _for(a,b,c) for(a=b;a\u003cc;++a) long long func(int n); int main(void) { //freopen(\"d:\\\\test.txt\", \"r\", stdin); int n; scanf(\"%d\", \u0026n); printf(\"%lld\", func(n)); return 0; } //your source code here: Source Code: long long func(int n) { if(n\u003c2) return n; if (n % 2) return func(n / 2) + func(n - 2); else return func(n / 2); } Source Code: long long func(int n) { static long long dp[10005] = { 0,1 }; if (n \u003c 2) return n; else { int i; _for(i, 2, n + 1) { if (i % 2) dp[i] = dp[i / 2] + dp[i - 2]; else dp[i] = dp[i / 2]; } return dp[n]; } } ","date":"2022-09-12","objectID":"/jikao/:4:1","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"5.处理学生成绩文件 ","date":"2022-09-12","objectID":"/jikao/:5:0","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"题目要求 通过文件\"a.txt\"输入若干行学号、姓名、成绩，将每个学生信息存储于单向链表结点，要求节点连接次序为成绩由大到小次序。将结点按连接次序输出到文件\"b.txt\"。 测试输入文件\"a.txt\"（数据的分隔符为空格和换行）： 1001 张三 72 1002 王晓华 80 1003 Alice 55 1004 欧阳文修 95 测试输出文件\"b.txt\": 1004 欧阳文修 95 1002 王晓华 80 1001 张三 72 1003 Alice 55 解题思路：输入完一个结点，就把这个结点插入到链表的正确位置，这样输入完后链表就是有序的，就可以直接输出到b文件。 Wrong answer\r据改卷老师说法，此题不能采用先把结点排好序再连成链表，或者先连成链表再在链表上排序的做法。\rSource Code: #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cstring.h\u003e #pragma warning(disable:4996) #define _for(a,b,c) for(a=b;a\u003cc;++a) typedef struct node { int id, grd; char name[25]; struct node* next, * last; }node; typedef struct list { node* head; }list; list* crtl(); node* crtn(int id, int grd, char* n); void clear(list* l); int main(void) { FILE* fp = fopen(\"d:\\\\a.txt\", \"r\"); list* L = crtl(); int id, grd; char tn[25]; node* p; while (fscanf(fp, \"%d %s %d\", \u0026id, tn, \u0026grd) != EOF) { node* newn = crtn(id, grd, tn); for (p = L-\u003ehead; p-\u003enext \u0026\u0026 p-\u003enext-\u003egrd \u003e grd; p = p-\u003enext); newn-\u003enext = p-\u003enext; p-\u003enext = newn; } fclose(fp);fp = fopen(\"d:\\\\b.txt\", \"w\"); p = L-\u003ehead-\u003enext; while (p) { fprintf(fp, \"%d %s %d\\n\", p-\u003eid, p-\u003ename, p-\u003egrd); p = p-\u003enext; } fclose(fp);clear(L); return 0; } list* crtl() { list* L = (list*)malloc(sizeof(list)); L-\u003ehead = crtn(0, 0, \"H\"); return L; } node* crtn(int id, int grd, char* n) { node* ret = (node*)malloc(sizeof(node)); ret-\u003eid = id, ret-\u003egrd = grd; strcpy(ret-\u003ename, n); ret-\u003enext = ret-\u003elast = NULL; return ret; } void clear(list* l) { node* p = l-\u003ehead, * t; while (p) { t = p; p = p-\u003enext; free(t); } free(l); } ","date":"2022-09-12","objectID":"/jikao/:5:1","tags":null,"title":"2022年西南交通大学计算机与人工智能学院转专业机考试题","uri":"/jikao/"},{"categories":["college"],"content":"\rWarning\r本文信息来自个人经历、部分同学分享、学院公告，无法涵盖有关转专业的所有内容。由于未进行全面调查，文中的观点主观性较强。欢迎各位读者指正谬误或遗漏之处，本文也将逐渐更新完善！\rNote\r暂时不深入涉及转专业成功以后流程。\r","date":"2022-09-12","objectID":"/changemajor/:0:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"前言 高考失利后，我不出意外的和CS相关的专业失之交臂，那时我便做好了转专业的打算。转专业的难度和压力不亚于高考，经历一年的考验我已转入软件工程专业。转专业的过程充满了各种不确定性，信息的匮乏经常使我感到迷茫。因此我趁着目前较为充裕的时间，将关于转专业（特别是计院）的信息进行汇总，并分享自己的心得体会。希望这篇文章对想转入计算机学院的同学有所帮助。 ","date":"2022-09-12","objectID":"/changemajor/:1:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"个人介绍 年级：2021级 原专业：数学与应用数学 转入专业：软件工程 ","date":"2022-09-12","objectID":"/changemajor/:2:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"利弊 我想，既然打开了此篇文章的同学，大部分做好了充分的思想准备，但是不是每一名同学都具备转计院成功的精力和能力，并且即使具备也不能断言转计院就是全局最优解，或是适合进行计算机方面的学习和工作。同时我也面向思想正在动摇，对于自己是否应该转计院犹豫不决的同学，说不定你看下去会觉得这是个宝贵的机会。 ","date":"2022-09-12","objectID":"/changemajor/:3:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"好处： 行业前景： 以下是19-21年国家统计局发布的各行业就业人员平均工资： 可见IT行业在具有最高平均工资水平的同时，依然维持较高增速。而计院专业主要面向IT行业中最热门的互联网行业。 计院三个专业虽上层建筑不同，但都以CS为基础，因此认真完成本科阶段学习的同学在进入IT行业工作时具备了其他专业同学所望尘莫及的编程能力和牢固基础。三个专业毕业后就业方向主要分为：前端，后端，全栈，算法，嵌入式，每一个方向都有很高的技术要求，面试官更注重应聘者的编程实力而不是文凭或者交际能力，一般来说本科毕业想直接工作就需要提前选择一个方向进行深入练习。 本校就业情况\r根据计算机学院某知名教授透露，软件工程2018级（本科）毕业生签约合同上的平均年薪15万。软件工程15-17级(本科)毕业生平均年薪为17万。其中水平较高者收获了50万以上年薪。\r实现超越： 相信有很多同学和我一样，高考分数可以上这个学校，但不能上这个学校的计算机专业。如果要上计算机专业的话只能退而求其次选择双非学校。 2021年我校所有专业里面计算机是收分最高的，我校在很多省份录取的高考最高分的同学都选择就读计算机专业。 如果转专业成功就同时获得可以读满意的学校和满意的专业。鉴于计算机类年年攀升的录取分数，转专业可以通过一年的劳动实现获得自己想学专业的本科学位，而如果跨考研究生或毕业后再参加培训班则不得不浪费四年的时间学习与自己志向无关的知识（前提是你今后想成为程序员），或只好改变志向。 换句话说，转专业等效于用一年的时间和精力换取高考多几分的待遇。 多样考核： 以计院为例，转专业将参考学生的准入课、四级、机考、面试成绩，可以说是考察了学生全方面的能力，即使学生在某一方面实力并不突出，也可以通过其他方面弥补。 如有同学在机考（实际上因为疫情变成笔试）中发挥糟糕，但还是凭借较高的准入课分和四级分稳住了排名。同时还有和我一起参加考核的同学在面试前的排名中居于末尾，结果凭借出彩的面试表现提高了自己的排名从而被录取。 因此我认为计院的转专业制度具有较好的容错性。多样的考核机制使得失误的影响降低了。 ","date":"2022-09-12","objectID":"/changemajor/:3:1","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"坏处： 不确定性： 这一点我深有体会，转专业的各方面信息经常残缺且自相矛盾。考前咨询老师的问题很少得到正面答复。在准备的过程中对于自己是否合格也始终无法得到准确的答案。更可怕的是因为极端原因突然修改了考核方式，这一点我深有体会：因为疫情机考和面试改为线上进行，但是机考竟然变成了手写代码的形式，一方面失去了编译器的检查功能，另一方面大大增强了改卷的主观性。而且老师拒绝回复关于题型的问题（有没有选择填空都不说），我直到拿到卷子才知道没有选择填空。 这些不确定性会让你做不少的无效劳动，有时甚至让你感到愤怒。 沉没成本： 学习不是大学生活的全部，阅读、运动、社交、兴趣爱好同样是大学生活的一部分，而转专业会占据你大量的空余时间，结果便是你需要延续高三的学习强度，无法在时间最充裕的一年级体会丰富的大学生活。而如果转专业以失败告终，那你大一失去的时间、付出的精力将付诸东流。 心理压力： 转专业的欲望越强烈，越容易受到外界扰动的刺激，心理压力也越大。你白天学习的时候会忍不住浏览论坛搜寻其他同学对于转专业的讨论，然后被一些危言耸听搞得六神无主，结果因为焦虑无法集中注意力。晚上会翻来覆去思索转专业失败的对策，无法入睡。和亲友交谈时，你得到了鼓励却感觉是难以实现的期望，你得到了安慰却感觉是失败主义的灌输。这都是你需要承受的心理包袱，它们可能会损害你的身体健康和人际关系。 适应变化： 即使转专业成功也要面临专业现实情况和自己想象的落差。一方面，需要补大一没上的必修课，导致平时作业多时间紧（但计院早八确实很少）。另一方面，迁移到新的集体中需要适应这个集体的管理特点（各学院和班级有截然不同的氛围）。另一方面，需要处理转专业成功后繁琐的事务，比如课程替代，团组织身份转移，重新选课。 Dormitary\r关于寝室：若住在犀浦，学校不会安排更换寝室，若要更换寝室需要走常规流程（一般很不容易）。若住在九里，学校会安排更换寝室，学生自主表决。若同意，去哪个寝室取决于人数情况，和同专业同学是舍友概率较小。 更换寝室手续非常繁琐而且牵扯搬运生活用品。并且最终如果舍友和自己专业不一样的话会出现作息时间冲突的问题。\rTL:DR\r对于有志进入IT业（特别是互联网、软件业）的同学来说，转专业是花费时间最短，以能力为唯一标准的机会。然而想把握住这个机会需要持之以恒的努力、大一处于持续紧张的精神状态。同时，机遇与风险共存，走上转专业的道路就要做好迎接失败的心理准备。\r","date":"2022-09-12","objectID":"/changemajor/:3:2","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"指标 即使你经过权衡利弊后，认为转计院是个好主意，也不能忽视你将面临的挑战。很多同学被会问诸如XX转计算机好转吗之类的问题，我在这里与其给出一个“很卷”、“还行”的答案，不如把成功的指标展示出来，你在心里对难度做评估。 ","date":"2022-09-12","objectID":"/changemajor/:4:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"录取比例 2021年90人参加机考，36人进入面试，20人被录取。 进入面试比例为40%，录取比例为22%。 2022年77人参加机考，30人进入面试，25人被录取。 进入面试比例为39%，录取比例为32%。 ","date":"2022-09-12","objectID":"/changemajor/:4:1","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"能力要求（以2022年被录取学生为准） 准入课成绩平均分： 高等数学I （数学分析I）：92.52 高等数学II（数学分析II) ：95.80 线性代数B (高等代数I和高等代数II中较高的一门)：93.76 四级成绩平均分：570.04 机考平均分：78.6 六级通过人数：16 必修课算术平均分：88.4412 ","date":"2022-09-12","objectID":"/changemajor/:4:2","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"误区 唯原专业排名论 这里简称原专业排名为原排。 事实上，原排的重要性在各大论坛（尤其是贴吧）被夸大了，几乎每一个询问转计院的帖子都会强调原排的重要性，甚至有人夸张地声称只有每个学院第一第二名才有机会。 然而原专业排名既不是门槛，也不是直接指标，只是面试时的参考因素。2022年没有出现因为低原排而不让同学参加机考的情况。筛选同学进入面试时，只根据准入课、四级、机考三项指标，无视原排。我在面试时老师也没有询问我的原排。鉴于面试占总分的25%，而原排只是面试时的参考因素之一，可以得出结论原排不是转计院的决定因素，更不可能出现其他方面优秀，因为原排低而被淘汰的现象。 证据方面，我通过比对往年录取名单，发现既有同学原排极高被淘汰，又有同学原排甚至未达前40%而被录取。 专业区别论 我一开始以为三个专业分别有自己的名额，并且报不同的专业就不在一起排名。在这个假设之下，我根据报CS的人数远多于报软工的人数，而去年AI招收人数远少于SE招收人数，我得出了报SE会增加录取机会的错误结论。 事实上我的假设一开始就是错的，并且我发现论坛上也有这种假设。参加转计院的所有学生会一起排名，报考的专业不会对成功率有任何影响。最终录取也是学院按照总分排名从高到低选拔。假如计院录取名额为N，那么有且仅有总分排名前N的同学被录取，即使他们全部都报CS也不会有任何影响。 ","date":"2022-09-12","objectID":"/changemajor/:4:3","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"流程 ","date":"2022-09-12","objectID":"/changemajor/:5:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"相关公告 转专业管理办法 点击图片下载PDF文件\r无论转入哪个学院，该文件都交代了一些基本的原则和注意事项。 转专业细则 一般大一上学期教务网会发布各学院的转专业实施细则，辅导员也会通知。建议结合往年的细则获得更全面的信息。 细则中将会给出准入课程，成绩计算公式，录取名额，时间安排等关键信息，最好反复仔细阅读。 2021年计算机与人工智能转专业实施细则 2022年各学院转专业实施细则 隐藏信息 计算机学院的网站上发布的关于其他事件的公告有的隐藏有对转专业有用的信息。这些信息可能没有在转专业细则上提及，也没有在这些公告的标题上提及，更没有人员专门通知。如在关于CCF CSP考试的公告文件里指出了免机考条件： Warning\r由于有同学反映学校不认可CSP成绩，此类隐藏信息最好通过联系学院老师查证!\r","date":"2022-09-12","objectID":"/changemajor/:5:1","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"提交申请 上图通知发布后便可按照指示提交转专业申请，在截止时间之前可对申请表进行修改或取消申请。鉴于六级成绩公布时间接近截止时间，建议出六级成绩在申请表上填写六级成绩。 Dont worry\r在转专业录取名单公布之前，该申请表会一直处于未审核状态。因此不用因此焦虑。\r","date":"2022-09-12","objectID":"/changemajor/:5:2","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"机考通知 开学前后一个星期，计院官网将会公布机考和面试的时间安排 此时也会有短信通知(按照惯例应公布考场，但22年因疫情改为线上进行) Danger\r若未收到短信，建议这段时间检查一下手机是否拦截了通知。我亲眼所见一名同学因短信被拦截而错过了加群的时间直接导致丧失资格。\r","date":"2022-09-12","objectID":"/changemajor/:5:3","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"机考（基于2020-2022） 时间限制：2小时 题型：编程 难度：约等于二级C语言考试，或各大OJ平台入门题难度 考查范围：C语言程序设计基础知识（结构化程序设计、文件操作、指针）、链表操作（不会考其他数据结构或算法） 考试环境： 学校机房，装有vs2019，代码提交后不会告知通过情况(线下形式) 正面+侧面两个设备进入腾讯会议并开启摄像头，手写代码（2022年的线上形式，我估计不会重现) 真题： 2021年机考真题敬请参阅supersass的文章 2022年计算机与人工智能学院转专业机考试题 Future plan\r信院的转专业机考和计院考察范围一致，内容和形式虽有差别，但要求的能力一样。日后本文将补充2022年信息与技术学院转专业机考试题。\r","date":"2022-09-12","objectID":"/changemajor/:5:4","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"面试 学院将根据成绩计算公式算出综合分进行排名，划定名额后按排名从高到低选拔学生进入面试。 面试短信通知： 面试院网通知： 面试考核内容： 限制在1分钟内的自我介绍 用英语回答一个问题：Please describe your hometown. 原专业的相关信息 针对自我介绍中的信息提问，如我参加了程序设计竞赛问我的参赛经历，参加了数学建模问我在队伍中担任的角色 若评委老师没有其他问题则面试结束 Limit\r可能是因为排在后面，我的面试仅持续了6分钟就结束了，问的问题也不全面，如果有同学想分享自己的面试经历欢迎联系我\r","date":"2022-09-12","objectID":"/changemajor/:5:5","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"结果公示 面试结束后不久，院网就会发布拟录取名单。至此，无论结果如何，转专业的斗争也就画上了句号。 ","date":"2022-09-12","objectID":"/changemajor/:5:6","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"建议 个人认为重要性：机考\u003e准入课\u003e四级成绩\u003e课外经历\u003e通过六级\u003e原专业排名，鉴于22年情况特殊，机考在纸上进行，很多准备充分的同学也未获得较高的机考成绩。但通常情况下机考在电脑上操作，因为拥有编译器的检查机制，同时可以自己调试从而减少了意外情况的发生，可以充分发挥实力。同时机考题目难度很低，掌握C语言的语法并大量刷题，就能很轻易拿到满分，给自己带来巨大优势。 若有多余时间最好参加竞赛或学习做项目。如参加程序设计竞赛、数学建模，写个贪吃蛇的小游戏之类的。这些不一定要做到极致，比如我大一参加的三个竞赛名气都不大，拿的奖项也不突出。但可避免自己在面试时处于被动（面试有很大概率询问计算机相关课外经历） ","date":"2022-09-12","objectID":"/changemajor/:6:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"},{"categories":["college"],"content":"总结 以上是我历时一年成功转码的全部心得，希望能让将踏上我的道路的同学对于转计院有个全面的认识。 此篇文章存在很多疏漏之处，欢迎联系我指出，我也会逐渐完善。 最后祝各位想转计院的同学能通过努力实现自己目标！ Share\r喜欢这篇文章的读者若能分享给其他读者我将感激不尽！\r","date":"2022-09-12","objectID":"/changemajor/:7:0","tags":null,"title":"西南交通大学转专业心得分享","uri":"/changemajor/"}]